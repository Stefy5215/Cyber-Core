include <Servo.h>

// -------------------- SERVO -------------------- //
Servo steeringServo;
const int ServoPin = A0;
const int ServoCenter = 93;
const int RightAngle = 40;
const int LeftAngle = 138;

// -------------------- MOTOR Y RPM (L298N) -------------------- //
const int ENB = 11;   // PWM
const int IN3 = 12;
const int IN4 = 13;

const byte sensorPin = 2;    // Hall sensor KY-003
const int imanes = 4;

volatile unsigned long ultimoPulso = 0;
volatile unsigned long intervalo = 0;

float rpm = 0;
float objetivo = 120.0;   // RPM objetivo
int pwm = 100;
float Kp = 0.9;
float tolerancia = 1.5;
unsigned long ultimaActualizacion = 0;
unsigned long ultimoBoost = 0;
bool enBoost = false;

// --- Deteccion de quietud ---
int ultimoEstadoSensor = HIGH;
unsigned long ultimoCambioSensor = 0;
const unsigned long tiempoQuieto = 800;

// -------------------- ULTRASONICOS (DEFINICIÓN DE PINES solo) -------------------- //
// Frontales
const int trigFrontLeft = 3;
const int echoFrontLeft = 4;
const int trigFrontRight = 5;
const int echoFrontRight = 6;
// Laterales
const int trigSideLeft = 7;
const int echoSideLeft = 8;
const int trigSideRight = 9;
const int echoSideRight = 10;

// -------------------- LÓGICA DE LÍNEAS -------------------- //
String lineaColor = "NONE";     // valor actual recibido via serial
bool lineaActiva = false;       // estamos en maniobra de línea
String primeraLinea = "NONE";   // AZUL o NARANJA cuando empezó la maniobra
bool esperandoDesaparicionSegunda = false; // true cuando segunda línea apareció y esperamos que desaparezca

// -------------------- CONTROL SERVO -------------------- //
float anguloActual = ServoCenter;
const float suavizado = 0.35;        // menos suavizado → más brusco y reactivo
const float factorInvToAngle = 0.65; // más ganancia → reacción más agresiva

// -------------------- ULTRASONIDOS LATERALES -------------------- //
long distanciaIzq = 0;  // distancia pared izquierda
long distanciaDer = 0;  // distancia pared derecha
// Pesos dinámicos según invasión
float pesoInvasion = 0.70;      // 70% invasión de paredes (ajustable)
float pesoUltrasonico = 0.30;   // 30% ultrasonidos laterales (ajustable)

// -------------------- FUNCIONES -------------------- //
void contarPulsos() {
  unsigned long ahora = micros();
  if (ultimoPulso > 0) intervalo = ahora - ultimoPulso;
  ultimoPulso = ahora;
}

// parsea una línea tipo "INV_L:45,INV_R:10,LINE:AZUL"
void parsearLinea(String s, int &invL, int &invR, String &lineStr) {
  invL = 0; invR = 0; lineStr = "NONE";
  s.trim();
  int idxL = s.indexOf("INV_L:");
  int idxR = s.indexOf("INV_R:");
  int idxLine = s.indexOf("LINE:");

  if (idxL >= 0) {
    int start = idxL + 6;
    int end = s.indexOf(',', start);
    if (end < 0) end = s.length();
    invL = s.substring(start, end).toInt();
  }
  if (idxR >= 0) {
    int start = idxR + 6;
    int end = s.indexOf(',', start);
    if (end < 0) end = s.length();
    invR = s.substring(start, end).toInt();
  }
  if (idxLine >= 0) {
    int start = idxLine + 5;
    String rest = s.substring(start);
    rest.trim();
    int comma = rest.indexOf(',');
    if (comma >= 0) rest = rest.substring(0, comma);
    rest.trim();
    rest.toUpperCase();
    if (rest.length() > 0) lineStr = rest;
  }
}

void aplicarAnguloAlServo(float ang) {
  ang = constrain(ang, RightAngle, LeftAngle);
  steeringServo.write((int)ang);
}

long medirDistancia(int trigPin, int echoPin) {
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  long duracion = pulseIn(echoPin, HIGH);
  return duracion * 0.034 / 2;
}

// -------------------- SETUP -------------------- //
void setup() {
  Serial.begin(115200);
  steeringServo.attach(ServoPin);
  steeringServo.write(ServoCenter);
  anguloActual = ServoCenter;

  // Pines motor
  pinMode(ENB, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);

  // Sensor Hall
  pinMode(sensorPin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(sensorPin), contarPulsos, FALLING);

  // Ultrasonicos: solo definimos modos (no usados en lógica ahora)
  pinMode(trigFrontLeft, OUTPUT);
  pinMode(echoFrontLeft, INPUT);
  pinMode(trigFrontRight, OUTPUT);
  pinMode(echoFrontRight, INPUT);
  pinMode(trigSideLeft, OUTPUT);
  pinMode(echoSideLeft, INPUT);
  pinMode(trigSideRight, OUTPUT);
  pinMode(echoSideRight, INPUT);

  // arrancar motor adelante (L298N)
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);

  Serial.println("✅ Arduino listo: recibe INV_L, INV_R, LINE -> ejecuta lógica; RPM activo.");
}

// -------------------- LOOP PRINCIPAL -------------------- //
void loop() {
  unsigned long ahora = millis();

  // -------------------- LECTURA SERIAL NO BLOQUEANTE -------------------- //
  while (Serial.available()) {
    String linea = Serial.readStringUntil('\n');
    linea.trim();
    if (linea.length() == 0) continue;

    int invL = 0, invR = 0;
    String recibLine = "NONE";
    parsearLinea(linea, invL, invR, recibLine);

    // seguridad límites
    invL = constrain(invL, 0, 100);
    invR = constrain(invR, 0, 100);
    lineaColor = recibLine;

    // -------------------- LECTURA ULTRASONIDOS LATERALES -------------------- //
    distanciaIzq = medirDistancia(trigSideLeft, echoSideLeft);
    distanciaDer = medirDistancia(trigSideRight, echoSideRight);

    // -------------------- LÓGICA DE LÍNEAS (estado) -------------------- //
    if (lineaColor != "NONE" && !lineaActiva) {
      lineaActiva = true;
      primeraLinea = lineaColor;
      esperandoDesaparicionSegunda = false;
      Serial.print("MANIOBRA INICIADA: ");
      Serial.println(primeraLinea);
    }
    else if (lineaActiva && lineaColor != "NONE" && lineaColor != primeraLinea && !esperandoDesaparicionSegunda) {
      esperandoDesaparicionSegunda = true;
      Serial.print("SEGUNDA LINEA APARECIO: ");
      Serial.println(lineaColor);
    }
    else if (lineaActiva && esperandoDesaparicionSegunda && lineaColor == "NONE") {
      lineaActiva = false;
      primeraLinea = "NONE";
      esperandoDesaparicionSegunda = false;
      Serial.println("MANIOBRA COMPLETADA -> volver a centrar por paredes");
    }

    // reacción inmediata en recepción:
    if (lineaActiva) {
      // Durante maniobra de líneas: reducir importancia, usar solo invasión suave
      float errorInvasion = (float)(invR - invL);
      float nuevoAngulo;
      
      if (primeraLinea == "NARANJA") {
        nuevoAngulo = RightAngle + (errorInvasion * 0.15); // corrección mínima
      } else if (primeraLinea == "AZUL") {
        nuevoAngulo = LeftAngle - (errorInvasion * 0.15); // corrección mínima
      } else {
        nuevoAngulo = ServoCenter;
      }
      
      nuevoAngulo = constrain(nuevoAngulo, RightAngle, LeftAngle);
      anguloActual = (0.7 * anguloActual) + (0.3 * nuevoAngulo); // suavizado extra
      aplicarAnguloAlServo(anguloActual);
    } else {
      // -------------------- CENTRADO CON INVASIÓN + ULTRASONIDOS -------------------- //
      // 1. Cálculo del error por invasión de paredes
      float errorInvasion = (float)(invR - invL);
      
      // 2. Cálculo del error por ultrasonidos laterales
      // Si izquierda está más cerca -> error negativo (girar derecha)
      // Si derecha está más cerca -> error positivo (girar izquierda)
      float errorUltrasonico = 0.0;
      if (distanciaIzq > 0 && distanciaDer > 0) {
        // Normalizar a un rango similar a invasión (-100 a 100)
        float diff = (float)(distanciaDer - distanciaIzq);
        // Mayor sensibilidad: cada cm de diferencia = ~8 unidades (antes 5)
        errorUltrasonico = constrain(diff * 8.0, -80.0, 80.0);
      }
      
      // 3. AJUSTE DINÁMICO DE PESOS según nivel de invasión
      int invasionMax = max(invL, invR);
      if (invasionMax > 75) {
        // Invasión alta (>75%): priorizar invasión fuertemente
        pesoInvasion = 0.95;
        pesoUltrasonico = 0.05;
      } else if (invasionMax < 55) {
        // Invasión baja (<55%): priorizar ultrasonidos
        pesoInvasion = 0.25;
        pesoUltrasonico = 0.75;
      } else {
        // Zona intermedia: balanceado
        pesoInvasion = 0.60;
        pesoUltrasonico = 0.40;
      }
      
      // 4. Combinar ambos errores con pesos dinámicos
      float errorCombinado = (errorInvasion * pesoInvasion) + (errorUltrasonico * pesoUltrasonico);
      
      // 5. Aplicar al servo
      float nuevoAngulo = (float)ServoCenter + (errorCombinado * factorInvToAngle);
      nuevoAngulo = constrain(nuevoAngulo, RightAngle, LeftAngle);
      anguloActual = (suavizado * anguloActual) + ((1.0 - suavizado) * nuevoAngulo);
      aplicarAnguloAlServo(anguloActual);
    }
  } // fin lectura serial

  // -------------------- CONTROL RPM (no bloqueante) -------------------- //
  int estadoSensor = digitalRead(sensorPin);
  if (estadoSensor != ultimoEstadoSensor) {
    ultimoCambioSensor = ahora;
    ultimoEstadoSensor = estadoSensor;
  }
  if (intervalo > 0) rpm = (60000000.0 / (intervalo * imanes));
  bool sensorQuieto = (ahora - ultimoCambioSensor > tiempoQuieto);

  // Boost si está detenido o sensor quieto por más de 800ms
  if (sensorQuieto) {
    // Si el sensor no detecta cambios (sin imán o con imán fijo) por 800ms
    pwm = 255;
    digitalWrite(IN3, HIGH);
    digitalWrite(IN4, LOW);
    analogWrite(ENB, pwm);
    enBoost = true;
    ultimoCambioSensor = ahora; // resetear para evitar spam
  } else {
    enBoost = false;
  }

  // Regulador proporcional
  if (ahora - ultimaActualizacion >= 100 && !enBoost) {
    float error = objetivo - rpm;
    if (error > tolerancia) pwm += (int)(Kp * error * 1.5);
    else if (error < -tolerancia) pwm -= (int)(Kp * abs(error) * 0.6);
    
    pwm = constrain(pwm, 70, 255);
    digitalWrite(IN3, HIGH);
    digitalWrite(IN4, LOW);
    analogWrite(ENB, pwm);
    ultimaActualizacion = ahora;
  }

  // No delay() -> loop rápido, respuesta inmediata.
}
