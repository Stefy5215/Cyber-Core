# -*- coding: utf-8 -*-
"""codigo de wro

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pX0RxbrEuRnYDHGyYV8L7C9Y78_nP9uv
"""

#!/usr/bin/env python3
"""
wro_roi_color_logic_gpio.py
- Igual que el original pero controla motor y servo directamente desde GPIO de la Raspberry Pi
- Usa gpiozero (y opcionalmente pigpio) para Motor y Servo
- Elimina toda la lÃ³gica de serial/Arduino
- Sistema de navegaciÃ³n con magnetÃ³metro para contador de vueltas y seguridad
"""

import cv2
import numpy as np
import threading
import time
import argparse
import json
import os
import math

# GPIO
try:
    from gpiozero import Motor, Servo, PWMOutputDevice, DigitalOutputDevice, Button
    # Intentar usar pigpio para mejor PWM en servos
    try:
        from gpiozero.pins.pigpio import PiGPIOFactory
        factory = PiGPIOFactory()
    except Exception:
        factory = None
except Exception as e:
    print("Error importando gpiozero:", e)
    print("Instala gpiozero (y pigpio si quieres mejor control de servos).")
    raise

# MagnetÃ³metro HMC5883L/QMC5883L - Usando I2C directo con smbus2
try:
    from smbus2 import SMBus

    # Intentar detectar QMC5883L primero (direcciÃ³n 0x0D)
    QMC5883L_ADDRESS = 0x0D
    HMC5883L_ADDRESS = 0x1E
    bus = SMBus(1)

    magnetometro_tipo = None

    # Probar QMC5883L
    try:
        # Configurar QMC5883L
        bus.write_byte_data(QMC5883L_ADDRESS, 0x0B, 0x01)  # Soft reset
        time.sleep(0.01)
        bus.write_byte_data(QMC5883L_ADDRESS, 0x09, 0x1D)  # ConfiguraciÃ³n: OSR=512, RNG=8G, ODR=200Hz, Mode=Continuous
        magnetometro_tipo = "QMC5883L"
        magnetometro_address = QMC5883L_ADDRESS
        print("âœ“ MagnetÃ³metro QMC5883L detectado (direcciÃ³n 0x0D)")
    except:
        # Si falla, probar HMC5883L
        try:
            bus.write_byte_data(HMC5883L_ADDRESS, 0x00, 0x70)  # Config A: 8 samples, 15Hz, normal
            bus.write_byte_data(HMC5883L_ADDRESS, 0x01, 0xA0)  # Config B: Gain
            bus.write_byte_data(HMC5883L_ADDRESS, 0x02, 0x00)  # Modo continuo
            magnetometro_tipo = "HMC5883L"
            magnetometro_address = HMC5883L_ADDRESS
            print("âœ“ MagnetÃ³metro HMC5883L detectado (direcciÃ³n 0x1E)")
        except:
            raise Exception("No se detectÃ³ ningÃºn magnetÃ³metro")

    def read_raw_data(addr):
        """Lee datos raw del magnetÃ³metro"""
        high = bus.read_byte_data(magnetometro_address, addr)
        low = bus.read_byte_data(magnetometro_address, addr + 1)
        value = ((high << 8) | low)
        if value > 32768:
            value = value - 65536
        return value

    def leer_magnetometro_xyz():
        """Lee los valores X, Y, Z del magnetÃ³metro"""
        try:
            if magnetometro_tipo == "QMC5883L":
                # QMC5883L: registros 0x00-0x05 (X_LSB, X_MSB, Y_LSB, Y_MSB, Z_LSB, Z_MSB)
                x_low = bus.read_byte_data(magnetometro_address, 0x00)
                x_high = bus.read_byte_data(magnetometro_address, 0x01)
                y_low = bus.read_byte_data(magnetometro_address, 0x02)
                y_high = bus.read_byte_data(magnetometro_address, 0x03)
                z_low = bus.read_byte_data(magnetometro_address, 0x04)
                z_high = bus.read_byte_data(magnetometro_address, 0x05)

                x = ((x_high << 8) | x_low)
                y = ((y_high << 8) | y_low)
                z = ((z_high << 8) | z_low)

                # Convertir a signed
                if x > 32768: x -= 65536
                if y > 32768: y -= 65536
                if z > 32768: z -= 65536

            else:  # HMC5883L
                x = read_raw_data(0x03)
                z = read_raw_data(0x05)
                y = read_raw_data(0x07)

            return [x, y, z]
        except Exception as e:
            print(f"Error leyendo magnetÃ³metro: {e}")
            return [0, 0, 0]

    MAGNETOMETRO_DISPONIBLE = True
    print(f"âœ“ MagnetÃ³metro {magnetometro_tipo} inicializado correctamente")

except Exception as e:
    print(f"âš ï¸  MagnetÃ³metro no disponible: {e}")
    print("   Instalando: pip3 install smbus2")
    MAGNETOMETRO_DISPONIBLE = False
    magnetometro_tipo = None
    leer_magnetometro_xyz = None

# Pines GPIO para el motor L298N
MOTOR_ENB = 13  # Enable B (PWM)
MOTOR_IN3 = 26  # DirecciÃ³n 1
MOTOR_IN4 = 19  # DirecciÃ³n 2
SERVO_PIN = 18  # Pin del servo
HALL_SENSOR_PIN = 17  # Pin del sensor Hall KY-003 para RPM

# -----------------------
# Config
# -----------------------
CAM_INDEX = 0      # CÃ¡mara para detecciÃ³n de lÃ­neas (abajo centro)
CAM_INDEX_2 = 2    # CÃ¡mara para detecciÃ³n de paredes (arriba izquierda)
CAM_INDEX_3 = 4    # CÃ¡mara 3 (arriba derecha) - ajusta el Ã­ndice segÃºn tu sistema
FRAME_W = 640
FRAME_H = 360

# ROI para detecciÃ³n de lÃ­neas (CÃ¡mara 1)
C_RECT = (int(FRAME_W*0.25), int(FRAME_H*0.65), int(FRAME_W*0.5), int(FRAME_H*0.25))
x_c, y_c, w_c, h_c = C_RECT

# ROI horizontal para detecciÃ³n de paredes en CAM2 - AL LADO DERECHO (pegado al borde)
CAM2_ROI = (FRAME_W - 300, FRAME_H - 170, 300, 80)  # x, y, ancho, alto - derecha

# ROI horizontal para detecciÃ³n de paredes en CAM3 - AL LADO IZQUIERDO (pegado al borde)
CAM3_ROI = (0, FRAME_H - 170, 300, 80)  # izquierda

# ROIs adicionales debajo - mÃ¡s largos
CAM2_ROI_BAJO = (FRAME_W - 400, FRAME_H - 80, 400, 80)  # debajo derecha - mucho mÃ¡s largo
CAM3_ROI_BAJO = (0, FRAME_H - 80, 400, 80)  # debajo izquierda - mucho mÃ¡s largo

# Valores HSV fijos para detecciÃ³n de colores - SIN TRACKBARS
BLUE_LO = np.array([90, 150, 80])    # SaturaciÃ³n mÃ­nima aumentada: 100â†’150, Brillo: 50â†’80
BLUE_HI = np.array([130, 255, 255])
ORANGE_LO = np.array([5, 120, 120])
ORANGE_HI = np.array([22, 255, 255])
BLACK_THRESHOLD = 100

STEER_LIMIT = 400
STEER_LIMIT_RIGHT = 320  # LÃ­mite reducido hacia la derecha (para evitar que la llanta tope con el bumper)
WALL_GAIN = 10.0  # Reducido para reacciÃ³n mÃ¡s suave a las paredes
VELOCIDAD_FIJA = 120  # Velocidad moderada (120/255 = ~47% PWM) - REDUCIDA para control mÃ¡s seguro

# Ajuste: mapear velocidad a 0..1 para gpiozero Motor
MAX_PWM = 255.0  # ajusta si tu escala es otra (se usa velocidad/MAX_PWM)

# ConfiguraciÃ³n del sistema de navegaciÃ³n CON CONTEO POR LÃNEAS DETECTADAS
LINEAS_POR_SENTIDO = 12  # 12 lÃ­neas detectadas en un sentido antes de cambiar
LINEAS_TOTALES = 24  # Total: 12 + 12 = 24 lÃ­neas detectadas
VUELTAS_TOTALES = 24  # Alias para compatibilidad
MAX_ANGULO_SEGURIDAD = 45  # Grados mÃ¡ximos de giro sin detectar segunda lÃ­nea
ANGULO_VUELTA_COMPLETA = 360  # Grados para considerar una vuelta completa
ANGULO_CAMBIO_SENTIDO = 180  # Grados para girar y cambiar de sentido
TOLERANCIA_ANGULO = 10  # Tolerancia en grados para detecciÃ³n de vuelta
TOLERANCIA_CAMBIO_SENTIDO = 20  # Tolerancia para verificar cambio de sentido completado

# ConfiguraciÃ³n del control de RPM con sensor Hall
TARGET_RPM = 50  # RPM objetivo reducido (era 80) - MÃS LENTO Y CONTROLADO
RPM_TOLERANCE = 10  # Tolerancia Â±10 RPM (mÃ¡s amplia)
PULSE_FORWARD_MS = 150  # DuraciÃ³n pulso adelante (ms) - MÃS LARGO
PULSE_BRAKE_MS = 30    # DuraciÃ³n pulso freno (ms) - REDUCIDO para evitar retroceso excesivo
PULSE_INTERVAL = 0.05  # Intervalo entre pulsos (50ms) - MÃS FRECUENTE
HALL_MAGNETS = 2       # NÃºmero de imanes en la rueda

# ConfiguraciÃ³n de detecciÃ³n de lÃ­neas continuas - MUY ESTRICTO
LINE_MIN_WIDTH = 80    # Ancho mÃ­nimo de lÃ­nea (muy gruesas - 80 pÃ­xeles)
LINE_MIN_PIXELS = 150  # NÃºmero mÃ­nimo de pÃ­xeles (muy largas - 150 pÃ­xeles)

# -----------------------
# Utils (idÃ©nticos a tu versiÃ³n)
# -----------------------
def mask_color_hsv(bgr, lo, hi):
    """DetecciÃ³n HSV pura SIN filtros morfolÃ³gicos"""
    hsv = cv2.cvtColor(bgr, cv2.COLOR_BGR2HSV)
    m = cv2.inRange(hsv, lo, hi)
    # SIN kernel, SIN MORPH_OPEN, SIN MORPH_CLOSE - detecciÃ³n pura
    return m

CONFIG_PATH = os.path.expanduser("~/.wro_color_config.json")

def save_color_config(path, blue_lo, blue_hi, orange_lo, orange_hi, cameras_swapped=False, b_range=None, o_range=None, camera_mapping=None):
    """Guarda configuraciÃ³n de colores incluyendo los rangos B_range y O_range y mapeo de cÃ¡maras"""
    data = {
        'blue_lo': [int(x) for x in blue_lo.tolist()],
        'blue_hi': [int(x) for x in blue_hi.tolist()],
        'orange_lo': [int(x) for x in orange_lo.tolist()],
        'orange_hi': [int(x) for x in orange_hi.tolist()],
        'cameras_swapped': cameras_swapped
    }
    # Guardar rangos si se proporcionan
    if b_range is not None:
        data['b_range'] = int(b_range)
    if o_range is not None:
        data['o_range'] = int(o_range)
    # Guardar mapeo de cÃ¡maras si se proporciona
    if camera_mapping is not None:
        data['camera_mapping'] = {int(k): int(v) for k, v in camera_mapping.items()}

    try:
        with open(path, 'w') as f:
            json.dump(data, f, indent=2)
        print(f"Saved color config to {path}")
        if b_range is not None or o_range is not None:
            print(f"  B_range={b_range}, O_range={o_range}")
        if camera_mapping is not None:
            print(f"  Camera mapping: {camera_mapping}")
    except Exception as e:
        print("Failed saving color config:", e)

def load_color_config(path, blue_lo, blue_hi, orange_lo, orange_hi):
    """Carga configuraciÃ³n de colores incluyendo los rangos light/mid/dark y mapeo de cÃ¡maras"""
    if not os.path.exists(path):
        return False, False, None, None, None, None, None, None, None
    try:
        with open(path, 'r') as f:
            data = json.load(f)
        blue_lo[:] = np.array(data.get('blue_lo', blue_lo.tolist()))
        blue_hi[:] = np.array(data.get('blue_hi', blue_hi.tolist()))
        orange_lo[:] = np.array(data.get('orange_lo', orange_lo.tolist()))
        orange_hi[:] = np.array(data.get('orange_hi', orange_hi.tolist()))
        cameras_swapped = data.get('cameras_swapped', False)

        # Cargar rangos light/mid/dark guardados (si existen)
        b_light_saved = data.get('b_light', None)
        b_mid_saved = data.get('b_mid', None)
        b_dark_saved = data.get('b_dark', None)
        o_light_saved = data.get('o_light', None)
        o_mid_saved = data.get('o_mid', None)
        o_dark_saved = data.get('o_dark', None)

        # Cargar mapeo de cÃ¡maras guardado (si existe)
        camera_mapping_saved = data.get('camera_mapping', None)
        if camera_mapping_saved is not None:
            # Convertir claves de string a int
            camera_mapping_saved = {int(k): int(v) for k, v in camera_mapping_saved.items()}

        print(f"Loaded color config from {path}")
        if any([b_light_saved, b_mid_saved, b_dark_saved, o_light_saved, o_mid_saved, o_dark_saved]):
            print(f"  B: light={b_light_saved}, mid={b_mid_saved}, dark={b_dark_saved}")
            print(f"  O: light={o_light_saved}, mid={o_mid_saved}, dark={o_dark_saved}")
        if camera_mapping_saved is not None:
            print(f"  Camera mapping: {camera_mapping_saved}")

        return True, cameras_swapped, b_light_saved, b_mid_saved, b_dark_saved, o_light_saved, o_mid_saved, o_dark_saved, camera_mapping_saved
    except Exception as e:
        print("Failed loading color config:", e)
        return False, False, None, None, None, None, None, None, None

# ===========================================
# CLASE NAVEGADOR CON MAGNETÃ“METRO
# ===========================================
class NavegadorMagnetometro:
    """Gestiona la navegaciÃ³n usando magnetÃ³metro para contar vueltas y seguridad"""

    def __init__(self, vueltas_totales=12, max_angulo_seguridad=45):
        self.vueltas_totales = vueltas_totales
        self.max_angulo_seguridad = max_angulo_seguridad

        # Estado del navegador
        self.direccion_inicial = None  # "IZQUIERDA" o "DERECHA"
        self.vueltas_completadas = 0
        self.angulo_inicial = None
        self.angulo_actual = 0
        self.angulo_desde_deteccion = 0
        self.activo = False
        self.completado = False

        # Variables para filtrado de lecturas
        self.ultimo_angulo_valido = 0
        self.ultimo_mag_x_valido = 0
        self.ultimo_mag_y_valido = 0
        self.ultimo_mag_z_valido = 0
        self.lecturas_consecutivas_cero = 0

        # CalibraciÃ³n
        self.angulo_offset = 0
        if MAGNETOMETRO_DISPONIBLE:
            self.calibrar()

    def calibrar(self):
        """Calibra el magnetÃ³metro tomando el Ã¡ngulo inicial como referencia"""
        if not MAGNETOMETRO_DISPONIBLE:
            return
        try:
            # Intentar varias veces hasta obtener lectura vÃ¡lida
            for intento in range(10):
                mag_data = leer_magnetometro_xyz()
                mag_x, mag_y = mag_data[0], mag_data[1]

                # Verificar que no sea una lectura de ceros
                if mag_x != 0 or mag_y != 0:
                    self.angulo_offset = math.atan2(mag_y, mag_x) * 180 / math.pi
                    self.ultimo_mag_x_valido = mag_x
                    self.ultimo_mag_y_valido = mag_y
                    print(f"ðŸ§­ MagnetÃ³metro calibrado - Ãngulo inicial: {self.angulo_offset:.1f}Â°")
                    return
                time.sleep(0.01)

            print("âš ï¸ No se pudo calibrar - usando offset 0")
        except Exception as e:
            print(f"Error calibrando magnetÃ³metro: {e}")

    def leer_angulo(self):
        """Lee el Ã¡ngulo actual del magnetÃ³metro (0-360Â°) con filtrado de lecturas invÃ¡lidas"""
        if not MAGNETOMETRO_DISPONIBLE:
            return self.ultimo_angulo_valido
        try:
            mag_data = leer_magnetometro_xyz()
            mag_x, mag_y = mag_data[0], mag_data[1]

            # Filtrar lecturas de cero (invÃ¡lidas)
            if mag_x == 0 and mag_y == 0:
                self.lecturas_consecutivas_cero += 1
                # Si hay muchas lecturas de cero consecutivas, puede ser un problema real
                if self.lecturas_consecutivas_cero > 50:
                    print("âš ï¸ Demasiadas lecturas de 0 - posible problema con magnetÃ³metro")
                    self.lecturas_consecutivas_cero = 0
                # Retornar Ãºltimo valor vÃ¡lido
                return self.ultimo_angulo_valido

            # Lectura vÃ¡lida - resetear contador
            self.lecturas_consecutivas_cero = 0
            self.ultimo_mag_x_valido = mag_x
            self.ultimo_mag_y_valido = mag_y

            # Calcular Ã¡ngulo
            angulo_raw = math.atan2(mag_y, mag_x) * 180 / math.pi
            # Normalizar a 0-360Â° relativo al Ã¡ngulo inicial
            angulo = (angulo_raw - self.angulo_offset) % 360

            # Guardar como Ãºltimo vÃ¡lido
            self.ultimo_angulo_valido = angulo
            return angulo

        except Exception as e:
            print(f"Error leyendo magnetÃ³metro: {e}")
            return self.ultimo_angulo_valido

    def iniciar_navegacion(self, direccion):
        """Inicia el sistema de navegaciÃ³n al detectar la primera lÃ­nea"""
        if direccion not in ["IZQUIERDA", "DERECHA"]:
            return False

        self.direccion_inicial = direccion
        self.angulo_inicial = self.leer_angulo()
        self.angulo_desde_deteccion = 0
        self.vueltas_completadas = 0
        self.activo = True
        self.completado = False

        print(f"\n{'='*50}")
        print(f"ðŸš€ NAVEGACIÃ“N INICIADA")
        print(f"   DirecciÃ³n: {direccion}")
        print(f"   Ãngulo inicial: {self.angulo_inicial:.1f}Â°")
        print(f"   Meta: {self.vueltas_totales} vueltas completas")
        print(f"{'='*50}\n")
        return True

    def actualizar(self):
        """Actualiza el estado del navegador - llamar cada frame"""
        if not self.activo or self.completado:
            return

        # Leer Ã¡ngulo actual
        self.angulo_actual = self.leer_angulo()

        # Calcular cambio de Ã¡ngulo desde la Ãºltima detecciÃ³n
        cambio_angulo = (self.angulo_actual - self.angulo_inicial) % 360

        # Ajustar segÃºn direcciÃ³n (izquierda = negativo, derecha = positivo)
        if self.direccion_inicial == "IZQUIERDA":
            if cambio_angulo > 180:
                cambio_angulo -= 360
        else:  # DERECHA
            if cambio_angulo > 180:
                cambio_angulo = 360 - cambio_angulo

        self.angulo_desde_deteccion = abs(cambio_angulo)

        # Detectar vuelta completa (360Â°)
        vueltas_actuales = int(self.angulo_desde_deteccion / 360)
        if vueltas_actuales > self.vueltas_completadas:
            self.vueltas_completadas = vueltas_actuales
            print(f"ðŸ”„ Vuelta {self.vueltas_completadas}/{self.vueltas_totales} completada!")

        # Verificar si completÃ³ todas las vueltas
        if self.vueltas_completadas >= self.vueltas_totales:
            self.completado = True
            self.activo = False
            print(f"\n{'='*50}")
            print(f"ðŸ Â¡NAVEGACIÃ“N COMPLETADA!")
            print(f"   {self.vueltas_totales} vueltas realizadas")
            print(f"{'='*50}\n")

    def verificar_seguridad_giro(self):
        """Verifica si el giro se pasÃ³ del Ã¡ngulo de seguridad sin detectar segunda lÃ­nea"""
        if not self.activo:
            return True  # OK, no estÃ¡ activo

        angulo_restante = self.angulo_desde_deteccion % 360
        if angulo_restante > self.max_angulo_seguridad:
            print(f"âš ï¸  SEGURIDAD: Giro excediÃ³ {self.max_angulo_seguridad}Â° - Deteniendo giro")
            return False  # NO OK, se pasÃ³

        return True  # OK, dentro del lÃ­mite

    def debe_continuar_girando(self):
        """Determina si debe continuar girando segÃºn la direcciÃ³n inicial"""
        if not self.activo or self.completado:
            return False
        return True

    def reset(self):
        """Reinicia el navegador"""
        self.direccion_inicial = None
        self.vueltas_completadas = 0
        self.angulo_inicial = None
        self.angulo_actual = 0
        self.angulo_desde_deteccion = 0
        self.activo = False
        self.completado = False
        print("ðŸ”„ Navegador reiniciado")

    def get_magnetometro_valores(self):
        """Retorna valores filtrados del magnetÃ³metro para visualizaciÃ³n"""
        if not MAGNETOMETRO_DISPONIBLE:
            return [0, 0, 0]

        try:
            # Intentar leer valores actuales
            mag_data = leer_magnetometro_xyz()
            mag_x, mag_y, mag_z = mag_data[0], mag_data[1], mag_data[2]

            # Si son ceros, usar Ãºltimos valores vÃ¡lidos
            if mag_x == 0 and mag_y == 0 and mag_z == 0:
                return [self.ultimo_mag_x_valido, self.ultimo_mag_y_valido, self.ultimo_mag_z_valido]

            # Guardar como Ãºltimos vÃ¡lidos
            self.ultimo_mag_z_valido = mag_z
            return mag_data
        except:
            return [self.ultimo_mag_x_valido, self.ultimo_mag_y_valido, self.ultimo_mag_z_valido]

    def get_info(self):
        """Retorna informaciÃ³n del estado actual para mostrar en pantalla"""
        if not self.activo:
            return "Navegador: Inactivo"

        return (f"Dir:{self.direccion_inicial[0]} | "
                f"Vueltas:{self.vueltas_completadas}/{self.vueltas_totales} | "
                f"Ãngulo:{self.angulo_desde_deteccion:.0f}Â° | "
                f"{'COMPLETADO' if self.completado else 'ACTIVO'}")

class ConsoleInputThread(threading.Thread):
    def __init__(self, blue_lo, blue_hi, orange_lo, orange_hi):
        super().__init__(daemon=True)
        self.blue_lo = blue_lo
        self.blue_hi = blue_hi
        self.orange_lo = orange_lo
        self.orange_hi = orange_hi
        self.running = True

    def run(self):
        print("Console controls: b+/b- o+/o- bh+/bh- bl+/bl- oh+/oh- ol+/ol- save status quit")
        while self.running:
            try:
                cmd = input().strip()
            except Exception:
                break
            if not cmd:
                continue
            if cmd == 'quit':
                print('Quit requested from console')
                os._exit(0)
            elif cmd == 'save':
                save_color_config(CONFIG_PATH, self.blue_lo, self.blue_hi, self.orange_lo, self.orange_hi)
            elif cmd == 'status':
                print('blue_lo', self.blue_lo.tolist(), 'blue_hi', self.blue_hi.tolist())
                print('orange_lo', self.orange_lo.tolist(), 'orange_hi', self.orange_hi.tolist())
            elif cmd in ('b+', 'b-'):
                delta = 1 if cmd == 'b+' else -1
                new_lo = max(0, int(self.blue_lo[0]) - delta)
                new_hi = min(179, int(self.blue_hi[0]) + delta)
                self.blue_lo[0] = new_lo
                self.blue_hi[0] = new_hi
                print('B_range adjusted ->', self.blue_lo[0], self.blue_hi[0])
            elif cmd in ('o+', 'o-'):
                delta = 1 if cmd == 'o+' else -1
                new_lo = max(0, int(self.orange_lo[0]) - delta)
                new_hi = min(179, int(self.orange_hi[0]) + delta)
                self.orange_lo[0] = new_lo
                self.orange_hi[0] = new_hi
                print('O_range adjusted ->', self.orange_lo[0], self.orange_hi[0])
            elif cmd in ('bh+', 'bh-'):
                delta = 1 if cmd == 'bh+' else -1
                self.blue_hi[0] = np.clip(self.blue_hi[0] + delta, 0, 179)
                print('blue_hi', int(self.blue_hi[0]))
            elif cmd in ('bl+', 'bl-'):
                delta = 1 if cmd == 'bl+' else -1
                self.blue_lo[0] = np.clip(self.blue_lo[0] + delta, 0, 179)
                print('blue_lo', int(self.blue_lo[0]))
            elif cmd in ('oh+', 'oh-'):
                delta = 1 if cmd == 'oh+' else -1
                self.orange_hi[0] = np.clip(self.orange_hi[0] + delta, 0, 179)
                print('orange_hi', int(self.orange_hi[0]))
            elif cmd in ('ol+', 'ol-'):
                delta = 1 if cmd == 'ol+' else -1
                self.orange_lo[0] = np.clip(self.orange_lo[0] + delta, 0, 179)
                print('orange_lo', int(self.orange_lo[0]))
            else:
                print('Unknown command:', cmd)

    def stop(self):
        self.running = False

def create_color_adjust_window(blue_lo, blue_hi, orange_lo, orange_hi):
    """Crea ventana de ajuste de colores con valores iniciales"""
    cv2.namedWindow("Adjust Colors", cv2.WINDOW_NORMAL)
    cv2.createTrackbar("B_H_lo", "Adjust Colors", int(blue_lo[0]), 179, lambda v: None)
    cv2.createTrackbar("B_S_lo", "Adjust Colors", int(blue_lo[1]), 255, lambda v: None)
    cv2.createTrackbar("B_V_lo", "Adjust Colors", int(blue_lo[2]), 255, lambda v: None)
    cv2.createTrackbar("B_H_hi", "Adjust Colors", int(blue_hi[0]), 179, lambda v: None)
    cv2.createTrackbar("B_S_hi", "Adjust Colors", int(blue_hi[1]), 255, lambda v: None)
    cv2.createTrackbar("B_V_hi", "Adjust Colors", int(blue_hi[2]), 255, lambda v: None)
    cv2.createTrackbar("O_H_lo", "Adjust Colors", int(orange_lo[0]), 179, lambda v: None)
    cv2.createTrackbar("O_S_lo", "Adjust Colors", int(orange_lo[1]), 255, lambda v: None)
    cv2.createTrackbar("O_V_lo", "Adjust Colors", int(orange_lo[2]), 255, lambda v: None)
    cv2.createTrackbar("O_H_hi", "Adjust Colors", int(orange_hi[0]), 179, lambda v: None)
    cv2.createTrackbar("O_S_hi", "Adjust Colors", int(orange_hi[1]), 255, lambda v: None)
    cv2.createTrackbar("O_V_hi", "Adjust Colors", int(orange_hi[2]), 255, lambda v: None)
    cv2.createTrackbar("B_range", "Adjust Colors", 10, 90, lambda v: None)
    cv2.createTrackbar("O_range", "Adjust Colors", 10, 90, lambda v: None)

def read_color_trackbar():
    bh_lo = cv2.getTrackbarPos("B_H_lo", "Adjust Colors")
    bs_lo = cv2.getTrackbarPos("B_S_lo", "Adjust Colors")
    bv_lo = cv2.getTrackbarPos("B_V_lo", "Adjust Colors")
    bh_hi = cv2.getTrackbarPos("B_H_hi", "Adjust Colors")
    bs_hi = cv2.getTrackbarPos("B_S_hi", "Adjust Colors")
    bv_hi = cv2.getTrackbarPos("B_V_hi", "Adjust Colors")

    oh_lo = cv2.getTrackbarPos("O_H_lo", "Adjust Colors")
    os_lo = cv2.getTrackbarPos("O_S_lo", "Adjust Colors")
    ov_lo = cv2.getTrackbarPos("O_V_lo", "Adjust Colors")
    oh_hi = cv2.getTrackbarPos("O_H_hi", "Adjust Colors")
    os_hi = cv2.getTrackbarPos("O_S_hi", "Adjust Colors")
    ov_hi = cv2.getTrackbarPos("O_V_hi", "Adjust Colors")

    blue_lo = np.array([bh_lo, bs_lo, bv_lo])
    blue_hi = np.array([bh_hi, bs_hi, bv_hi])
    orange_lo = np.array([oh_lo, os_lo, ov_lo])
    orange_hi = np.array([oh_hi, os_hi, ov_hi])

    try:
        b_range = cv2.getTrackbarPos("B_range", "Adjust Colors")
    except Exception:
        b_range = 0
    try:
        o_range = cv2.getTrackbarPos("O_range", "Adjust Colors")
    except Exception:
        o_range = 0

    if b_range > 0:
        center_h = int((blue_lo[0] + blue_hi[0]) / 2)
        blue_lo[0] = max(0, center_h - b_range)
        blue_hi[0] = min(179, center_h + b_range)

    if o_range > 0:
        center_h = int((orange_lo[0] + orange_hi[0]) / 2)
        orange_lo[0] = max(0, center_h - o_range)
        orange_hi[0] = min(179, center_h + o_range)

    return blue_lo, blue_hi, orange_lo, orange_hi

def mask_black_gray(bgr, thresh=BLACK_THRESHOLD):
    gray = cv2.cvtColor(bgr, cv2.COLOR_BGR2GRAY)
    mean_val = np.mean(gray)
    dynamic_thresh = min(thresh, int(mean_val * 0.8))
    _, m = cv2.threshold(gray, dynamic_thresh, 255, cv2.THRESH_BINARY_INV)
    mask_white = cv2.inRange(gray, 200, 255)
    m = cv2.bitwise_and(m, cv2.bitwise_not(mask_white))
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3,3))
    m = cv2.morphologyEx(m, cv2.MORPH_OPEN, kernel, iterations=1)
    m = cv2.morphologyEx(m, cv2.MORPH_CLOSE, kernel, iterations=1)
    # NO FILTRAR POR FORMA - aceptar todo lo que se detectÃ³
    return m

def invasion_ratio(mask):
    area = mask.shape[0] * mask.shape[1]
    if area == 0:
        return 0.0
    inv = cv2.countNonZero(mask) / float(area)
    return inv

def lowest_point_of_mask(mask):
    ys, xs = np.where(mask > 0)
    if len(ys) == 0:
        return None
    return int(np.max(ys))

def detect_continuous_line(mask, min_width=50, min_pixels=100):
    """
    Detecta solo lÃ­neas continuas, ignorando pÃ­xeles aislados.

    Args:
        mask: MÃ¡scara binaria
        min_width: Ancho mÃ­nimo que debe tener la lÃ­nea (pÃ­xeles)
        min_pixels: NÃºmero mÃ­nimo de pÃ­xeles totales

    Returns:
        y_position: PosiciÃ³n Y de la lÃ­nea, o None si no hay lÃ­nea continua
    """
    # Buscar contornos en la mÃ¡scara
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    if len(contours) == 0:
        return None

    # Buscar el contorno mÃ¡s grande
    largest_contour = max(contours, key=cv2.contourArea)
    area = cv2.contourArea(largest_contour)

    # Verificar que tenga suficientes pÃ­xeles
    if area < min_pixels:
        return None

    # Obtener bounding box del contorno mÃ¡s grande
    x, y, w, h = cv2.boundingRect(largest_contour)

    # Verificar que sea una lÃ­nea horizontal (ancho > alto)
    if w < min_width:
        return None

    # Verificar que sea horizontal (aspect ratio > 2)
    aspect_ratio = w / float(h) if h > 0 else 0
    if aspect_ratio < 2.0:
        return None

    # Retornar el punto mÃ¡s bajo del contorno
    return int(y + h)

def es_cubo_o_linea(x, y, w, h):
    aspect_ratio = w / float(h)
    if aspect_ratio < 1.0:
        return "CUBO"
    elif aspect_ratio > 3.0:
        return "LINEA"
    return "DESCONOCIDO"

def verificar_relieve(mask_edges, x, y, w, h):
    roi_edges = mask_edges[y:y+h, x:x+w]
    edge_count = cv2.countNonZero(roi_edges)
    if edge_count > 50:
        return True
    return False

def excluir_region(mask, x, y, w, h):
    mask[y:y+h, x:x+w] = 0

def verificar_posicion(x, y, w, h, frame_height):
    if y + h > frame_height * 0.9:
        return "SUELO"
    return "VALIDO"

def verificar_continuidad(mask_orange, x, y, w, h):
    roi = mask_orange[y:y+h, x:x+w]
    line_continuity = cv2.countNonZero(roi) / float(w * h)
    if line_continuity > 0.8:
        return True
    return False

def detectar_cubo_y_linea(frame, mask_red, mask_orange, mask_edges, frame_height):
    contours_red, _ = cv2.findContours(mask_red, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for cnt in contours_red:
        x, y, w, h = cv2.boundingRect(cnt)
        if verificar_posicion(x, y, w, h, frame_height) == "SUELO":
            continue
        if es_cubo_o_linea(x, y, w, h) == "CUBO" and verificar_relieve(mask_edges, x, y, w, h):
            cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 0, 255), 2)
            cv2.putText(frame, "CUBO ROJO DETECTADO", (x, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
            excluir_region(mask_orange, x, y, w, h)

    contours_orange, _ = cv2.findContours(mask_orange, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    for cnt in contours_orange:
        x, y, w, h = cv2.boundingRect(cnt)
        if es_cubo_o_linea(x, y, w, h) == "LINEA" and verificar_continuidad(mask_orange, x, y, w, h):
            cv2.rectangle(frame, (x, y), (x+w, y+h), (0, 140, 255), 2)
            cv2.putText(frame, "LINEA NARANJA DETECTADA", (x, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 140, 255), 2)

# -----------------------
# Capture thread
# -----------------------
class CaptureThread(threading.Thread):
    def __init__(self, index=0, w=FRAME_W, h=FRAME_H):
        super().__init__(daemon=True)
        self.cap = cv2.VideoCapture(index)
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, w)
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, h)
        self.lock = threading.Lock()
        self.frame = None
        self.running = True

    def run(self):
        time.sleep(0.2)
        while self.running:
            ret, f = self.cap.read()
            if not ret:
                continue
            with self.lock:
                self.frame = f.copy()
        self.cap.release()

    def read(self):
        with self.lock:
            return None if self.frame is None else self.frame.copy()

    def stop(self):
        self.running = False

# -----------------------
# Main logic (ahora con gpiozero)
# -----------------------
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--show", action="store_true", help="Mostrar ventanas")
    args = parser.parse_args()

    # Inicializar valores de colores
    blue_lo = BLUE_LO.copy()
    blue_hi = BLUE_HI.copy()
    orange_lo = ORANGE_LO.copy()
    orange_hi = ORANGE_HI.copy()

    # Variable para controlar intercambio de cÃ¡maras
    cameras_swapped = False

    # Variables para ajuste de brillo de cÃ¡maras
    brightness_cam1 = 0  # Ajuste de brillo para cÃ¡mara 1 (-100 a +100)
    brightness_cam2 = 0  # Ajuste de brillo para cÃ¡mara 2 (-100 a +100)

    # Variables para el sistema de intercambio de cÃ¡maras
    camera_selected = None  # None, 1, 2, o 3
    # Mapeo de cÃ¡maras fÃ­sicas a posiciones lÃ³gicas
    # Por defecto: posiciÃ³n 1 -> CAM_INDEX (0), posiciÃ³n 2 -> CAM_INDEX_2 (2), posiciÃ³n 3 -> CAM_INDEX_3 (4)
    camera_mapping = {1: 0, 2: 1, 3: 2}  # posiciÃ³n lÃ³gica -> Ã­ndice en lista de captures

    # Cargar configuraciÃ³n guardada ANTES de crear la ventana
    b_light_saved = None
    b_mid_saved = None
    b_dark_saved = None
    o_light_saved = None
    o_mid_saved = None
    o_dark_saved = None
    camera_mapping_saved = None
    try:
        loaded, cameras_swapped, b_light_saved, b_mid_saved, b_dark_saved, o_light_saved, o_mid_saved, o_dark_saved, camera_mapping_saved = load_color_config(CONFIG_PATH, blue_lo, blue_hi, orange_lo, orange_hi)
        if loaded:
            print("âœ“ ConfiguraciÃ³n de colores cargada desde archivo guardado")
            if cameras_swapped:
                print("âœ“ ConfiguraciÃ³n de cÃ¡maras: INTERCAMBIADAS")
            else:
                print("âœ“ ConfiguraciÃ³n de cÃ¡maras: NORMAL")
            # Aplicar mapeo de cÃ¡maras guardado
            if camera_mapping_saved is not None:
                camera_mapping = camera_mapping_saved
                print(f"âœ“ Mapeo de cÃ¡maras restaurado: {camera_mapping}")
        else:
            print("  Usando configuraciÃ³n de colores por defecto")
    except Exception as e:
        print(f"  No se pudo cargar configuraciÃ³n: {e}")
        cameras_swapped = False

    # Crear ventana simple SOLO para ajustar RANGO (H min/max) con light/mid/dark separados
    try:
        cv2.namedWindow("Adjust Range", cv2.WINDOW_NORMAL)
        # Calcular rango actual del azul y naranja
        blue_range_default = int((BLUE_HI[0] - BLUE_LO[0]) / 2)
        orange_range_default = int((ORANGE_HI[0] - ORANGE_LO[0]) / 2)

        # Usar valores guardados si existen, sino usar valores por defecto
        blue_light = b_light_saved if b_light_saved is not None else blue_range_default
        blue_mid = b_mid_saved if b_mid_saved is not None else blue_range_default
        blue_dark = b_dark_saved if b_dark_saved is not None else blue_range_default
        orange_light = o_light_saved if o_light_saved is not None else orange_range_default
        orange_mid = o_mid_saved if o_mid_saved is not None else orange_range_default
        orange_dark = o_dark_saved if o_dark_saved is not None else orange_range_default

        if b_light_saved is not None:
            print(f"âœ“ Valores azul cargados: light={blue_light}, mid={blue_mid}, dark={blue_dark}")
        if o_light_saved is not None:
            print(f"âœ“ Valores naranja cargados: light={orange_light}, mid={orange_mid}, dark={orange_dark}")

        # Crear trackbars para ajuste de tonos claros, medios y oscuros (H)
        cv2.createTrackbar("B_light", "Adjust Range", blue_light, 90, lambda v: None)
        cv2.createTrackbar("B_mid", "Adjust Range", blue_mid, 90, lambda v: None)
        cv2.createTrackbar("B_dark", "Adjust Range", blue_dark, 90, lambda v: None)
        cv2.createTrackbar("O_light", "Adjust Range", orange_light, 90, lambda v: None)
        cv2.createTrackbar("O_mid", "Adjust Range", orange_mid, 90, lambda v: None)
        cv2.createTrackbar("O_dark", "Adjust Range", orange_dark, 90, lambda v: None)

        # Trackbars para ajustar S (SaturaciÃ³n) y V (Brillo)
        cv2.createTrackbar("B_S_min", "Adjust Range", BLUE_LO[1], 255, lambda v: None)
        cv2.createTrackbar("B_S_max", "Adjust Range", BLUE_HI[1], 255, lambda v: None)
        cv2.createTrackbar("O_S_min", "Adjust Range", ORANGE_LO[1], 255, lambda v: None)
        cv2.createTrackbar("O_S_max", "Adjust Range", ORANGE_HI[1], 255, lambda v: None)

        print("âœ“ Ventana 'Adjust Range' creada")
        print("  - B_light/B_mid/B_dark: Ajusta azul claro/medio/oscuro (Hue)")
        print("  - O_light/O_mid/O_dark: Ajusta naranja claro/medio/oscuro (Hue)")
        print("  - B_S_min/max: Ajusta saturaciÃ³n azul")
        print("  - O_S_min/max: Ajusta saturaciÃ³n naranja")
    except Exception as e:
        print(f"No se pudo crear ventana de ajuste: {e}")

    # Mostrar valores HSV fijos al inicio
    print("\n" + "="*50)
    print("ðŸŽ¨ VALORES HSV BASE (ajustables por claridad)")
    print("="*50)
    print(f"ðŸ”µ BLUE:   H=centroÂ±rango S={BLUE_LO[1]}-{BLUE_HI[1]} V={BLUE_LO[2]}-{BLUE_HI[2]}")
    print(f"ðŸŸ  ORANGE: H=centroÂ±rango S={ORANGE_LO[1]}-{ORANGE_HI[1]} V={ORANGE_LO[2]}-{ORANGE_HI[2]}")
    print("="*50)
    print("âœ… SIN FILTROS MORFOLÃ“GICOS - DetecciÃ³n HSV pura")
    print("ðŸŽ›ï¸  Ajusta rangos en 'Adjust Range' (light/dark por color)")
    print("="*50 + "\n")

    # Inicializar cÃ¡maras
    print("\n=== Inicializando cÃ¡maras ===")
    cap = CaptureThread(CAM_INDEX, FRAME_W, FRAME_H)
    cap.start()
    print(f"âœ“ CÃ¡mara 1 (lÃ­neas): /dev/video{CAM_INDEX}")

    cap2 = CaptureThread(CAM_INDEX_2, FRAME_W, FRAME_H)
    cap2.start()
    print(f"âœ“ CÃ¡mara 2 (pared izq): /dev/video{CAM_INDEX_2}")

    cap3 = CaptureThread(CAM_INDEX_3, FRAME_W, FRAME_H)
    cap3.start()
    print(f"âœ“ CÃ¡mara 3 (pared der): /dev/video{CAM_INDEX_3}")

    time.sleep(0.5)

    input_thread = ConsoleInputThread(blue_lo, blue_hi, orange_lo, orange_hi)
    try:
        input_thread.start()
    except Exception:
        pass

    # --- Inicializar motor y servo en la Raspberry Pi ---
    # ConfiguraciÃ³n L298N:
    # ENB (Enable) -> GPIO 13 (PWM para velocidad)
    # IN3 -> GPIO 19 (direcciÃ³n)
    # IN4 -> GPIO 26 (direcciÃ³n)
    # Motor conectado a OUT3 y OUT4 del L298N
    try:
        # Crear clase wrapper para control del motor L298N con control de RPM
        class MotorL298N:
            def __init__(self, enable_pin, in1_pin, in2_pin, hall_pin):
                self.enable = DigitalOutputDevice(enable_pin)
                self.in1 = DigitalOutputDevice(in1_pin)
                self.in2 = DigitalOutputDevice(in2_pin)

                # Sensor Hall para medir RPM
                self.hall_sensor = Button(hall_pin, pull_up=True, bounce_time=0.01)
                self.pulse_count = 0
                self.last_rpm_time = time.time()
                self.current_rpm = 0

                # Variables de control de RPM
                self.target_rpm = TARGET_RPM
                self.last_pulse_time = time.time()
                self.is_running = False

                # Callback para contar pulsos del sensor Hall
                self.hall_sensor.when_pressed = self._on_hall_pulse

                # Activar enable al mÃ¡ximo
                self.enable.on()
                print(f"  âš¡ Motor con control de RPM inicializado")
                print(f"  ðŸ“Š TARGET_RPM: {TARGET_RPM}, Sensor Hall: GPIO{hall_pin}")

            def _on_hall_pulse(self):
                """Callback cuando el sensor Hall detecta un imÃ¡n"""
                self.pulse_count += 1

            def calculate_rpm(self):
                """Calcula RPM actual basado en pulsos del sensor Hall"""
                current_time = time.time()
                elapsed = current_time - self.last_rpm_time

                if elapsed >= 0.5:  # Calcular RPM cada 0.5 segundos
                    # RPM = (pulsos / imanes) / tiempo_en_minutos
                    rpm = (self.pulse_count / HALL_MAGNETS) / (elapsed / 60.0)
                    self.current_rpm = rpm
                    self.pulse_count = 0
                    self.last_rpm_time = current_time

                return self.current_rpm

            def pulse_forward(self, duration_ms):
                """Pulso hacia adelante para acelerar"""
                self.in1.on()
                self.in2.off()
                time.sleep(duration_ms / 1000.0)
                self.in1.off()
                self.in2.off()

            def pulse_brake(self, duration_ms):
                """Pulso de freno (hacia atrÃ¡s) para desacelerar"""
                self.in1.off()
                self.in2.on()
                time.sleep(duration_ms / 1000.0)
                self.in1.off()
                self.in2.off()

            def control_speed(self):
                """Controla la velocidad con pulsos basÃ¡ndose en RPM actual"""
                if not self.is_running:
                    return

                current_rpm = self.calculate_rpm()
                error = self.target_rpm - current_rpm

                current_time = time.time()

                # Aplicar pulsos mÃ¡s frecuentemente
                if current_time - self.last_pulse_time < PULSE_INTERVAL:
                    return

                if error > RPM_TOLERANCE:
                    # RPM muy bajo, acelerar con pulso hacia adelante
                    self.pulse_forward(PULSE_FORWARD_MS)
                    self.last_pulse_time = current_time
                elif error < -RPM_TOLERANCE:
                    # RPM muy alto, NO aplicar freno - solo detener pulsos momentÃ¡neamente
                    # Esto evita que el carro retroceda
                    time.sleep(PULSE_INTERVAL * 2)  # Pausa para dejar que desacelere
                    self.last_pulse_time = current_time
                # Si estÃ¡ dentro de la tolerancia, mantener pulsos suaves
                else:
                    # Aplicar pulso corto para mantener velocidad
                    self.pulse_forward(PULSE_FORWARD_MS // 2)
                    self.last_pulse_time = current_time

            def forward(self, speed=1.0):
                """Motor adelante con control de RPM"""
                self.enable.on()
                self.is_running = True
                self.control_speed()  # Aplicar control de velocidad

            def backward(self, speed=1.0):
                """Motor atrÃ¡s (sin control de RPM)"""
                self.enable.on()
                self.is_running = False
                self.in1.off()
                self.in2.on()

            def stop(self):
                """Detener motor con freno fuerte"""
                self.is_running = False
                # Freno fuerte: ambos pines HIGH
                self.in1.on()
                self.in2.on()
                time.sleep(0.05)
                self.in1.off()
                self.in2.off()

            def close(self):
                """Cerrar conexiones"""
                self.stop()
                self.enable.off()
                self.enable.close()
                self.in1.close()
                self.in2.close()

        motor = MotorL298N(MOTOR_ENB, MOTOR_IN3, MOTOR_IN4, HALL_SENSOR_PIN)

        if factory is not None:
            servo = Servo(SERVO_PIN, pin_factory=factory)
        else:
            servo = Servo(SERVO_PIN)

        print("GPIO motor y servo inicializados.")
        print(f"  Motor L298N: ENB=GPIO{MOTOR_ENB}, IN3=GPIO{MOTOR_IN3}, IN4=GPIO{MOTOR_IN4}")
        print(f"  Sensor Hall: GPIO{HALL_SENSOR_PIN}")
        print(f"  Servo: GPIO{SERVO_PIN}")
        print(f"  ðŸš¦ Control de RPM: TARGET={TARGET_RPM} RPM, Tolerancia=Â±{RPM_TOLERANCE}")
        print(f"  âš¡ Pulsos: Adelante={PULSE_FORWARD_MS}ms, Freno={PULSE_BRAKE_MS}ms")
        print(f"  ðŸ›‘ Freno fuerte: IN1+IN2=HIGH durante 50ms")
    except Exception as e:
        print("Error inicializando motor/servo:", e)
        motor = None
        servo = None

    print("Iniciando loop. Presionar ESC para salir.")
    print("\n=== CONTROLES ===")
    print("Intercambio de cÃ¡maras:")
    print("  1. Presiona '1', '2' o '3' para seleccionar una cÃ¡mara")
    print("  2. Luego presiona '1', '2' o '3' para intercambiarla con otra")
    print("  Ejemplo: '2' luego '3' = intercambia CAM2 con CAM3")
    print("\nAjuste de brillo:")
    print("  CAM1 (lÃ­neas): 'q' - / 'w' +")
    print("  CAM2 (paredes): 'e' - / 'r' +")

    # ==================================================
    # INICIALIZAR NAVEGADOR CON MAGNETÃ“METRO
    # ==================================================
    navegador = None
    if MAGNETOMETRO_DISPONIBLE:
        navegador = NavegadorMagnetometro(
            vueltas_totales=VUELTAS_TOTALES,
            max_angulo_seguridad=MAX_ANGULO_SEGURIDAD
        )
        print("\nðŸ§­ NAVEGADOR CON MAGNETÃ“METRO ACTIVO")
        print(f"   Tipo: {magnetometro_tipo}")
        print(f"   Meta: {VUELTAS_TOTALES} vueltas | LÃ­mite seguridad: {MAX_ANGULO_SEGURIDAD}Â°\n")
    else:
        print("\nâš ï¸  Navegador deshabilitado - MagnetÃ³metro no disponible\n")

    estado_giro = None
    linea_inicial = None

    # ===== SISTEMA DE CONTEO DE LÃNEAS DETECTADAS =====
    contador_lineas = 0  # Contador de LÃNEAS detectadas (no vueltas)
    fase_navegacion = "PRIMERA_ETAPA"  # PRIMERA_ETAPA, CAMBIO_SENTIDO, SEGUNDA_ETAPA, COMPLETADO
    angulo_inicio_cambio = None  # Ãngulo cuando inicia el cambio de sentido

    # ===== VARIABLES PARA MANIOBRA DE CAMBIO DE SENTIDO =====
    tiempo_inicio_maniobra = None  # Timestamp cuando inicia cada movimiento
    DURACION_AVANCE_CAMBIO = 1.0  # 1 segundo avanzando
    DURACION_RETROCESO_CAMBIO = 1.0  # 1 segundo retrocediendo
    PWM_CAMBIO_SENTIDO = 220  # PWM fijo para maniobra (0-255)
    direccion_giro_cambio = None  # "IZQUIERDA" o "DERECHA" - mantener el giro del Ãºltimo giro
    intentos_cambio_sentido = 0  # Contador de ciclos avance-retroceso
    MAX_INTENTOS_CAMBIO = 50  # MÃ¡ximo 50 ciclos de maniobra
    estado_maniobra = None  # "AVANZANDO" o "RETROCEDIENDO"

    try:
        frame_count = 0  # Contador de frames para debug
        ultimo_color_detectado = None  # Para mantener el color del contorno
        ultima_linea_procesada = None  # Para evitar procesar la misma lÃ­nea dos veces
        frames_sin_linea = 0  # Contador para resetear la Ãºltima lÃ­nea procesada
        FRAMES_PARA_RESETEAR = 30  # Resetear despuÃ©s de 1 segundo sin lÃ­neas (30 frames @ 30fps)

        while True:
            frame_count += 1  # Incrementar contador

            # Actualizar Ã¡ngulo del magnetÃ³metro SIEMPRE (incluso si no estÃ¡ activo)
            if navegador and MAGNETOMETRO_DISPONIBLE:
                navegador.angulo_actual = navegador.leer_angulo()

                # Si estÃ¡ activo, actualizar tambiÃ©n el conteo de vueltas
                if navegador.activo:
                    navegador.actualizar()

            # Leer frames de las 3 cÃ¡maras fÃ­sicas
            frames_raw = [cap.read(), cap2.read(), cap3.read()]

            if any(f is None for f in frames_raw):
                time.sleep(0.01)
                continue

            # Aplicar mapeo de cÃ¡maras - usar camera_mapping para reordenar
            frame_cam1 = frames_raw[camera_mapping[1]].copy()
            frame_cam2 = frames_raw[camera_mapping[2]].copy()
            frame_cam3 = frames_raw[camera_mapping[3]].copy()

            try:
                # CAM1 rotada 180 grados
                frame_cam1 = cv2.rotate(frame_cam1, cv2.ROTATE_180)

                # CAM2 rotada 180 grados
                frame_cam2 = cv2.rotate(frame_cam2, cv2.ROTATE_180)

                # CAM3 sin rotaciÃ³n
                # frame_cam3 permanece sin rotar
            except Exception:
                pass

            # Aplicar ajuste de brillo a cada cÃ¡mara
            if brightness_cam1 != 0:
                frame_cam1 = cv2.convertScaleAbs(frame_cam1, alpha=1.0, beta=brightness_cam1)
            if brightness_cam2 != 0:
                frame_cam2 = cv2.convertScaleAbs(frame_cam2, alpha=1.0, beta=brightness_cam2)

            # Asignar frames
            frame = frame_cam1.copy()    # CÃ¡mara 1 para lÃ­neas (abajo)
            frame2 = frame_cam2.copy()   # CÃ¡mara 2 para pared izquierda (arriba izq)
            frame3 = frame_cam3.copy()   # CÃ¡mara 3 para pared derecha (arriba der)

            disp = frame.copy()
            disp2 = frame2.copy()
            disp3 = frame3.copy()

            # PRIMERO extraer el ROI de lÃ­neas (solo esta zona se procesarÃ¡ para colores)
            roi_c = frame[y_c:y_c+h_c, x_c:x_c+w_c]

            # Leer rangos de la ventana de ajuste (light, mid y dark separados)
            try:
                b_light = cv2.getTrackbarPos("B_light", "Adjust Range")
                b_mid = cv2.getTrackbarPos("B_mid", "Adjust Range")
                b_dark = cv2.getTrackbarPos("B_dark", "Adjust Range")
                o_light = cv2.getTrackbarPos("O_light", "Adjust Range")
                o_mid = cv2.getTrackbarPos("O_mid", "Adjust Range")
                o_dark = cv2.getTrackbarPos("O_dark", "Adjust Range")

                # Leer valores de SaturaciÃ³n (S)
                b_s_min = cv2.getTrackbarPos("B_S_min", "Adjust Range")
                b_s_max = cv2.getTrackbarPos("B_S_max", "Adjust Range")
                o_s_min = cv2.getTrackbarPos("O_S_min", "Adjust Range")
                o_s_max = cv2.getTrackbarPos("O_S_max", "Adjust Range")

                # Calcular centros H (azul ~110, naranja ~13)
                blue_center_h = int((BLUE_LO[0] + BLUE_HI[0]) / 2)
                orange_center_h = int((ORANGE_LO[0] + ORANGE_HI[0]) / 2)

                # Crear mÃ¡scaras para AZUL claro, medio y oscuro (SOLO EN EL ROI)
                masks_blue = []

                # Azul claro (V alto: 180-255)
                if b_light > 0:
                    blue_lo_light = np.array([max(0, blue_center_h - b_light), b_s_min, 180])
                    blue_hi_light = np.array([min(179, blue_center_h + b_light), b_s_max, 255])
                    masks_blue.append(mask_color_hsv(roi_c, blue_lo_light, blue_hi_light))

                # Azul medio (V medio: 100-179)
                if b_mid > 0:
                    blue_lo_mid = np.array([max(0, blue_center_h - b_mid), b_s_min, 100])
                    blue_hi_mid = np.array([min(179, blue_center_h + b_mid), b_s_max, 179])
                    masks_blue.append(mask_color_hsv(roi_c, blue_lo_mid, blue_hi_mid))

                # Azul oscuro (V bajo: 50-99)
                if b_dark > 0:
                    blue_lo_dark = np.array([max(0, blue_center_h - b_dark), b_s_min, BLUE_LO[2]])
                    blue_hi_dark = np.array([min(179, blue_center_h + b_dark), b_s_max, 99])
                    masks_blue.append(mask_color_hsv(roi_c, blue_lo_dark, blue_hi_dark))

                # Combinar todas las mÃ¡scaras azules
                if masks_blue:
                    roi_mask_blue = masks_blue[0]
                    for m in masks_blue[1:]:
                        roi_mask_blue = cv2.bitwise_or(roi_mask_blue, m)
                else:
                    roi_mask_blue = mask_color_hsv(roi_c, BLUE_LO, BLUE_HI)

                # Crear mÃ¡scaras para NARANJA claro, medio y oscuro (SOLO EN EL ROI)
                masks_orange = []

                # Naranja claro (V alto: 200-255)
                if o_light > 0:
                    orange_lo_light = np.array([max(0, orange_center_h - o_light), o_s_min, 200])
                    orange_hi_light = np.array([min(179, orange_center_h + o_light), o_s_max, 255])
                    masks_orange.append(mask_color_hsv(roi_c, orange_lo_light, orange_hi_light))

                # Naranja medio (V medio: 150-199)
                if o_mid > 0:
                    orange_lo_mid = np.array([max(0, orange_center_h - o_mid), o_s_min, 150])
                    orange_hi_mid = np.array([min(179, orange_center_h + o_mid), o_s_max, 199])
                    masks_orange.append(mask_color_hsv(roi_c, orange_lo_mid, orange_hi_mid))

                # Naranja oscuro (V bajo: 120-149)
                if o_dark > 0:
                    orange_lo_dark = np.array([max(0, orange_center_h - o_dark), o_s_min, ORANGE_LO[2]])
                    orange_hi_dark = np.array([min(179, orange_center_h + o_dark), o_s_max, 149])
                    masks_orange.append(mask_color_hsv(roi_c, orange_lo_dark, orange_hi_dark))

                # Combinar todas las mÃ¡scaras naranjas
                if masks_orange:
                    roi_mask_orange = masks_orange[0]
                    for m in masks_orange[1:]:
                        roi_mask_orange = cv2.bitwise_or(roi_mask_orange, m)
                else:
                    roi_mask_orange = mask_color_hsv(roi_c, ORANGE_LO, ORANGE_HI)

            except Exception as e:
                # Si falla, usar valores fijos
                print(f"Error en trackbars: {e}")
                roi_mask_blue = mask_color_hsv(roi_c, BLUE_LO, BLUE_HI)
                roi_mask_orange = mask_color_hsv(roi_c, ORANGE_LO, ORANGE_HI)

            # ROI de lÃ­neas ya fue extraÃ­do arriba

            # ROI horizontal derecho en frame2 (cÃ¡mara 2)
            roi_cam2 = frame2[CAM2_ROI[1]:CAM2_ROI[1]+CAM2_ROI[3],
                             CAM2_ROI[0]:CAM2_ROI[0]+CAM2_ROI[2]]

            # ROI horizontal izquierdo en frame3 (cÃ¡mara 3)
            roi_cam3 = frame3[CAM3_ROI[1]:CAM3_ROI[1]+CAM3_ROI[3],
                             CAM3_ROI[0]:CAM3_ROI[0]+CAM3_ROI[2]]

            # ROIs adicionales debajo - mÃ¡s largos
            roi_cam2_bajo = frame2[CAM2_ROI_BAJO[1]:CAM2_ROI_BAJO[1]+CAM2_ROI_BAJO[3],
                                   CAM2_ROI_BAJO[0]:CAM2_ROI_BAJO[0]+CAM2_ROI_BAJO[2]]
            roi_cam3_bajo = frame3[CAM3_ROI_BAJO[1]:CAM3_ROI_BAJO[1]+CAM3_ROI_BAJO[3],
                                   CAM3_ROI_BAJO[0]:CAM3_ROI_BAJO[0]+CAM3_ROI_BAJO[2]]

            # MÃ¡scaras de paredes horizontales
            mask_wall_cam2 = mask_black_gray(roi_cam2)
            mask_wall_cam3 = mask_black_gray(roi_cam3)

            # MÃ¡scaras de ROIs adicionales debajo
            mask_wall_cam2_bajo = mask_black_gray(roi_cam2_bajo)
            mask_wall_cam3_bajo = mask_black_gray(roi_cam3_bajo)

            gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
            mask_edges = cv2.Canny(gray, 50, 150)
            mask_edges = cv2.dilate(mask_edges, cv2.getStructuringElement(cv2.MORPH_RECT, (3,3)), iterations=1)

            # ==================================================
            # DETECCIÃ“N DE LÃNEAS Y PAREDES
            # (DESACTIVADO durante CAMBIO_SENTIDO)
            # ==================================================
            if fase_navegacion == "CAMBIO_SENTIDO":
                # Durante cambio de sentido: NO detectar lÃ­neas ni paredes
                hay_azul = False
                hay_naranja = False
                inv_cam2_total = 0.0
                inv_cam3_total = 0.0
                wall_steer = 0
                linea_detectada = 0

                if frame_count % 30 == 0:
                    print("â¸ï¸  DetecciÃ³n de lÃ­neas/paredes DESACTIVADA durante CAMBIO_SENTIDO")
            else:
                # DETECCIÃ“N NORMAL DE LÃNEAS Y PAREDES

                # DetecciÃ³n de LÃNEAS CONTINUAS (ignora pÃ­xeles aislados) - usar mÃ¡scaras del ROI
                blue_low = detect_continuous_line(roi_mask_blue, min_width=LINE_MIN_WIDTH, min_pixels=LINE_MIN_PIXELS)
                orange_low = detect_continuous_line(roi_mask_orange, min_width=LINE_MIN_WIDTH, min_pixels=LINE_MIN_PIXELS)
                hay_azul = blue_low is not None
                hay_naranja = orange_low is not None

                # DEBUG: Contar pÃ­xeles y mostrar valores HSV del centro del ROI
                blue_pixels = cv2.countNonZero(roi_mask_blue)
                orange_pixels = cv2.countNonZero(roi_mask_orange)

                # Obtener valor HSV del centro del ROI para debug
                roi_center_y, roi_center_x = h_c // 2, w_c // 2
                roi_hsv = cv2.cvtColor(roi_c, cv2.COLOR_BGR2HSV)
                center_hsv = roi_hsv[roi_center_y, roi_center_x]

                print(f"ðŸ”µ AZUL: {blue_pixels} pÃ­xeles {'âœ“ DETECTADO' if hay_azul else 'âœ— NO DETECTADO'} | ðŸŸ  NARANJA: {orange_pixels} pÃ­xeles {'âœ“ DETECTADO' if hay_naranja else 'âœ— NO DETECTADO'}")
                print(f"  ðŸŽ¯ Centro ROI HSV: H={center_hsv[0]} S={center_hsv[1]} V={center_hsv[2]}")
                print(f"  ðŸ“Š Rangos ACTUALES - AZUL: H={blue_lo[0]}-{blue_hi[0]} | NARANJA: H={orange_lo[0]}-{orange_hi[0]}")

                # Usar las mÃ¡scaras horizontales para calcular invasiÃ³n de paredes
                # CAM2 detecta pared derecha, CAM3 detecta pared izquierda
                inv_cam2 = invasion_ratio(mask_wall_cam2)  # pared derecha (superior)
                inv_cam3 = invasion_ratio(mask_wall_cam3)  # pared izquierda (superior)
                inv_cam2_bajo = invasion_ratio(mask_wall_cam2_bajo)  # pared derecha (inferior)
                inv_cam3_bajo = invasion_ratio(mask_wall_cam3_bajo)  # pared izquierda (inferior)

                # DEBUG: contar pÃ­xeles blancos en mÃ¡scaras
                print(f"Pixeles paredes: CAM2={cv2.countNonZero(mask_wall_cam2)} CAM2_bajo={cv2.countNonZero(mask_wall_cam2_bajo)} CAM3={cv2.countNonZero(mask_wall_cam3)} CAM3_bajo={cv2.countNonZero(mask_wall_cam3_bajo)}")

                # Usar el mÃ¡ximo de ambos ROIs para cada lado
            inv_cam2_total = max(inv_cam2, inv_cam2_bajo)
            inv_cam3_total = max(inv_cam3, inv_cam3_bajo)

            # DEBUG: Mostrar valores en consola
            print(f"CAM2: sup={inv_cam2:.3f} inf={inv_cam2_bajo:.3f} total={inv_cam2_total:.3f} | CAM3: sup={inv_cam3:.3f} inf={inv_cam3_bajo:.3f} total={inv_cam3_total:.3f}")

            wall_steer = int(WALL_GAIN * 100 * (inv_cam2_total - inv_cam3_total))  # der - izq (invertido)

            steer = 0
            velocidad = VELOCIDAD_FIJA
            linea_detectada = 0

            # =================================================
            # LÃ“GICA DE GIRO CON NAVEGADOR MAGNETOMÃ‰TRICO
            # =================================================

            # ==================================================
            # VERIFICAR SI COMPLETÃ“ TODO EL RECORRIDO
            # ==================================================
            if fase_navegacion == "COMPLETADO":
                print("ðŸ RECORRIDO COMPLETADO - DETENIENDO ROBOT")
                if motor is not None:
                    motor.stop()
                if servo is not None:
                    servo.value = 0
                break  # Salir del loop principal

            # ==================================================
            # FASE DE CAMBIO DE SENTIDO (Maniobra con tiempo)
            # ==================================================
            if fase_navegacion == "CAMBIO_SENTIDO":
                # SÃ O SÃ hacer la maniobra (con o sin magnetÃ³metro)

                if navegador and MAGNETOMETRO_DISPONIBLE:
                    # CON MAGNETÃ“METRO: Verificar Ã¡ngulo y repetir hasta 180Â°
                    angulo_actual = navegador.leer_angulo()

                    # Calcular Ã¡ngulo girado desde el inicio
                    if angulo_inicio_cambio is not None:
                        diff = angulo_actual - angulo_inicio_cambio
                        while diff > 180:
                            diff -= 360
                        while diff < -180:
                            diff += 360
                        angulo_girado = abs(diff)

                        # VERIFICAR SI COMPLETÃ“ LOS 180Â° - Ã‰XITO
                        if angulo_girado >= (ANGULO_CAMBIO_SENTIDO - TOLERANCIA_CAMBIO_SENTIDO):
                            fase_navegacion = "SEGUNDA_ETAPA"
                            contador_lineas = 0
                            angulo_inicio_cambio = None
                            estado_giro = None
                            estado_maniobra = None
                            tiempo_inicio_maniobra = None
                            direccion_giro_cambio = None
                            linea_inicial = None
                            ultima_linea_procesada = None
                            print(f"\n{'='*60}")
                            print(f"âœ… CAMBIO DE SENTIDO COMPLETADO ({angulo_girado:.1f}Â°)")
                            print(f"   Total de ciclos: {intentos_cambio_sentido}")
                            print(f"   Iniciando SEGUNDA_ETAPA ({LINEAS_POR_SENTIDO} lÃ­neas mÃ¡s)")
                            print(f"{'='*60}\n")
                        elif intentos_cambio_sentido >= MAX_INTENTOS_CAMBIO:
                            # Seguridad: demasiados intentos
                            print(f"âš ï¸  CAMBIO DE SENTIDO - ExcediÃ³ {MAX_INTENTOS_CAMBIO} ciclos ({angulo_girado:.1f}Â°), continuando...")
                            fase_navegacion = "SEGUNDA_ETAPA"
                            contador_lineas = 0
                            angulo_inicio_cambio = None
                            estado_giro = None
                            estado_maniobra = None
                            tiempo_inicio_maniobra = None
                            direccion_giro_cambio = None
                        else:
                            # ===== MANIOBRA: Ciclos de 1 seg adelante + 1 seg atrÃ¡s =====
                            tiempo_actual = time.time()

                            # INICIAR PRIMERA MANIOBRA
                            if estado_maniobra is None:
                                estado_maniobra = "AVANZANDO"
                                tiempo_inicio_maniobra = tiempo_actual
                                intentos_cambio_sentido += 1
                                print(f"\nðŸ”„ Ciclo {intentos_cambio_sentido}: AVANZANDO 1 seg | {angulo_girado:.1f}Â°/180Â°")

                            # ESTADO: AVANZANDO (1 segundo)
                            elif estado_maniobra == "AVANZANDO":
                                tiempo_transcurrido = tiempo_actual - tiempo_inicio_maniobra

                                if tiempo_transcurrido >= DURACION_AVANCE_CAMBIO:
                                    # Cambiar a retroceso
                                    estado_maniobra = "RETROCEDIENDO"
                                    tiempo_inicio_maniobra = tiempo_actual
                                    print(f"ðŸ”„ Ciclo {intentos_cambio_sentido}: RETROCEDIENDO 1 seg | {angulo_girado:.1f}Â°/180Â°")
                                else:
                                    # Avanzar con el MISMO giro que el Ãºltimo giro de lÃ­nea
                                    if direccion_giro_cambio == "DERECHA":
                                        steer = STEER_LIMIT_RIGHT  # Girar a la derecha
                                        if frame_count % 10 == 0:
                                            print(f"   âž¡ï¸  AVANZANDO girando DERECHA (steer={steer})")
                                    else:  # "IZQUIERDA"
                                        steer = -STEER_LIMIT  # Girar a la izquierda
                                        if frame_count % 10 == 0:
                                            print(f"   â¬…ï¸  AVANZANDO girando IZQUIERDA (steer={steer})")

                                    # Motor adelante con PWM 220
                                    if motor is not None:
                                        pwm_normalized = PWM_CAMBIO_SENTIDO / 255.0  # 220/255 â‰ˆ 0.86
                                        motor.forward(pwm_normalized)

                                    linea_detectada = 1

                            # ESTADO: RETROCEDIENDO (1 segundo)
                            elif estado_maniobra == "RETROCEDIENDO":
                                tiempo_transcurrido = tiempo_actual - tiempo_inicio_maniobra

                                if tiempo_transcurrido >= DURACION_RETROCESO_CAMBIO:
                                    # CompletÃ³ el ciclo - volver a avanzar
                                    estado_maniobra = "AVANZANDO"
                                    tiempo_inicio_maniobra = tiempo_actual
                                    intentos_cambio_sentido += 1
                                    print(f"\nðŸ”„ Ciclo {intentos_cambio_sentido}: AVANZANDO 1 seg | {angulo_girado:.1f}Â°/180Â°")
                                else:
                                    # Retroceder con giro CONTRARIO
                                    if direccion_giro_cambio == "DERECHA":
                                        steer = -STEER_LIMIT  # Giro contrario = IZQUIERDA
                                        if frame_count % 10 == 0:
                                            print(f"   â¬…ï¸  RETROCEDIENDO girando IZQUIERDA (steer={steer})")
                                    else:  # "IZQUIERDA"
                                        steer = STEER_LIMIT_RIGHT  # Giro contrario = DERECHA
                                        if frame_count % 10 == 0:
                                            print(f"   âž¡ï¸  RETROCEDIENDO girando DERECHA (steer={steer})")

                                    # Motor atrÃ¡s con PWM 220
                                    if motor is not None:
                                        pwm_normalized = PWM_CAMBIO_SENTIDO / 255.0  # 220/255 â‰ˆ 0.86
                                        motor.backward(pwm_normalized)

                                    linea_detectada = 1

                else:
                    # SIN MAGNETÃ“METRO: Hacer 5 ciclos fijos y continuar
                    if intentos_cambio_sentido >= 5:
                        # CompletÃ³ los 5 ciclos
                        print(f"\n{'='*60}")
                        print(f"âœ… CAMBIO DE SENTIDO COMPLETADO (5 ciclos sin magnetÃ³metro)")
                        print(f"   Iniciando SEGUNDA_ETAPA ({LINEAS_POR_SENTIDO} lÃ­neas mÃ¡s)")
                        print(f"{'='*60}\n")
                        fase_navegacion = "SEGUNDA_ETAPA"
                        contador_lineas = 0
                        estado_giro = None
                        estado_maniobra = None
                        tiempo_inicio_maniobra = None
                        direccion_giro_cambio = None
                        linea_inicial = None
                        ultima_linea_procesada = None
                    else:
                        # ===== MANIOBRA: Ciclos de 1 seg adelante + 1 seg atrÃ¡s =====
                        tiempo_actual = time.time()

                        # INICIAR PRIMERA MANIOBRA
                        if estado_maniobra is None:
                            estado_maniobra = "AVANZANDO"
                            tiempo_inicio_maniobra = tiempo_actual
                            intentos_cambio_sentido += 1
                            print(f"\nðŸ”„ Ciclo {intentos_cambio_sentido}/5: AVANZANDO 1 seg (SIN magnetÃ³metro)")

                        # ESTADO: AVANZANDO (1 segundo)
                        elif estado_maniobra == "AVANZANDO":
                            tiempo_transcurrido = tiempo_actual - tiempo_inicio_maniobra

                            if tiempo_transcurrido >= DURACION_AVANCE_CAMBIO:
                                # Cambiar a retroceso
                                estado_maniobra = "RETROCEDIENDO"
                                tiempo_inicio_maniobra = tiempo_actual
                                print(f"ðŸ”„ Ciclo {intentos_cambio_sentido}/5: RETROCEDIENDO 1 seg")
                            else:
                                # Avanzar con el MISMO giro que el Ãºltimo giro de lÃ­nea
                                if direccion_giro_cambio == "DERECHA":
                                    steer = STEER_LIMIT_RIGHT  # Girar a la derecha
                                    if frame_count % 10 == 0:
                                        print(f"   âž¡ï¸  AVANZANDO girando DERECHA (steer={steer})")
                                else:  # "IZQUIERDA"
                                    steer = -STEER_LIMIT  # Girar a la izquierda
                                    if frame_count % 10 == 0:
                                        print(f"   â¬…ï¸  AVANZANDO girando IZQUIERDA (steer={steer})")

                                # Motor adelante con PWM 220
                                if motor is not None:
                                    pwm_normalized = PWM_CAMBIO_SENTIDO / 255.0  # 220/255 â‰ˆ 0.86
                                    motor.forward(pwm_normalized)

                                linea_detectada = 1

                        # ESTADO: RETROCEDIENDO (1 segundo)
                        elif estado_maniobra == "RETROCEDIENDO":
                            tiempo_transcurrido = tiempo_actual - tiempo_inicio_maniobra

                            if tiempo_transcurrido >= DURACION_RETROCESO_CAMBIO:
                                # CompletÃ³ el ciclo - volver a avanzar o terminar
                                if intentos_cambio_sentido >= 5:
                                    # Ya completÃ³ 5 ciclos, terminar en el prÃ³ximo frame
                                    estado_maniobra = None
                                else:
                                    estado_maniobra = "AVANZANDO"
                                    tiempo_inicio_maniobra = tiempo_actual
                                    intentos_cambio_sentido += 1
                                    print(f"\nðŸ”„ Ciclo {intentos_cambio_sentido}/5: AVANZANDO 1 seg")
                            else:
                                # Retroceder con giro CONTRARIO
                                if direccion_giro_cambio == "DERECHA":
                                    steer = -STEER_LIMIT  # Giro contrario = IZQUIERDA
                                else:  # "IZQUIERDA"
                                    steer = STEER_LIMIT_RIGHT  # Giro contrario = DERECHA

                                # Motor atrÃ¡s con PWM 220
                                if motor is not None:
                                    pwm_normalized = PWM_CAMBIO_SENTIDO / 255.0  # 220/255 â‰ˆ 0.86
                                    motor.backward(pwm_normalized)

                                linea_detectada = 1

                # No ejecutar lÃ³gica normal de giros durante cambio de sentido
                estado_giro = None

            # ==================================================
            # LÃ“GICA NORMAL DE DETECCIÃ“N Y GIRO
            # ==================================================
            elif estado_giro is None:
                # Contar frames sin detecciÃ³n para resetear la memoria
                if not hay_azul and not hay_naranja:
                    frames_sin_linea += 1
                    if frames_sin_linea >= FRAMES_PARA_RESETEAR:
                        ultima_linea_procesada = None
                        frames_sin_linea = 0
                else:
                    frames_sin_linea = 0

                # Iniciar giro cuando detecta solo UNA lÃ­nea Y no es la misma que acabamos de procesar
                if hay_azul and not hay_naranja:
                    if ultima_linea_procesada != "AZUL":
                        estado_giro = "IZQUIERDA"
                        linea_inicial = "AZUL"
                        ultima_linea_procesada = "AZUL"

                        # INCREMENTAR CONTADOR DE LÃNEAS
                        contador_lineas += 1
                        print(f"\n{'='*60}")
                        print(f"ï¿½ LÃNEA {contador_lineas}/{LINEAS_POR_SENTIDO} DETECTADA (AZUL)")
                        print(f"   Fase: {fase_navegacion}")
                        print(f"{'='*60}\n")

                        # NO cambiar fase aquÃ­ - esperar a que termine el giro completo

                        print("ðŸ”µ Iniciando giro IZQUIERDA")

                        # INICIAR NAVEGADOR
                        if navegador:
                            navegador.iniciar_navegacion("IZQUIERDA")
                    else:
                        print("â­ï¸  Ignorando AZUL (ya procesada)")

                elif hay_naranja and not hay_azul:
                    if ultima_linea_procesada != "NARANJA":
                        estado_giro = "DERECHA"
                        linea_inicial = "NARANJA"
                        ultima_linea_procesada = "NARANJA"

                        # INCREMENTAR CONTADOR DE LÃNEAS
                        contador_lineas += 1
                        print(f"\n{'='*60}")
                        print(f"ï¿½ LÃNEA {contador_lineas}/{LINEAS_POR_SENTIDO} DETECTADA (NARANJA)")
                        print(f"   Fase: {fase_navegacion}")
                        print(f"{'='*60}\n")

                        # NO cambiar fase aquÃ­ - esperar a que termine el giro completo

                        print("ðŸŸ  Iniciando giro DERECHA")

                        # INICIAR NAVEGADOR
                        if navegador:
                            navegador.iniciar_navegacion("DERECHA")
                    else:
                        print("â­ï¸  Ignorando NARANJA (ya procesada)")

            elif estado_giro == "IZQUIERDA":
                # Cambiar a "girando" cuando detecta la segunda lÃ­nea (naranja)
                if hay_naranja:
                    estado_giro = "GIRANDO_IZQUIERDA"
                    print("ðŸ”µâ†’ðŸŸ  Segunda lÃ­nea detectada, continuando giro...")

                # SEGURIDAD: Verificar lÃ­mite de Ã¡ngulo sin segunda lÃ­nea
                elif navegador and not navegador.verificar_seguridad_giro():
                    estado_giro = None
                    linea_inicial = None
                    print(f"âš ï¸  SEGURIDAD: Abortando giro - ExcediÃ³ {MAX_ANGULO_SEGURIDAD}Â° sin segunda lÃ­nea")

            elif estado_giro == "DERECHA":
                # Cambiar a "girando" cuando detecta la segunda lÃ­nea (azul)
                if hay_azul:
                    estado_giro = "GIRANDO_DERECHA"
                    print("ðŸŸ â†’ðŸ”µ Segunda lÃ­nea detectada, continuando giro...")

                # SEGURIDAD: Verificar lÃ­mite de Ã¡ngulo sin segunda lÃ­nea
                elif navegador and not navegador.verificar_seguridad_giro():
                    estado_giro = None
                    linea_inicial = None
                    print(f"âš ï¸  SEGURIDAD: Abortando giro - ExcediÃ³ {MAX_ANGULO_SEGURIDAD}Â° sin segunda lÃ­nea")

            elif estado_giro == "GIRANDO_IZQUIERDA":
                # Terminar giro solo cuando la segunda lÃ­nea (naranja) DESAPAREZCA
                if not hay_naranja:
                    # VERIFICAR SI ES LA LÃNEA 12 PARA CAMBIO DE SENTIDO
                    if fase_navegacion == "PRIMERA_ETAPA" and contador_lineas >= LINEAS_POR_SENTIDO:
                        # Iniciar fase de cambio de sentido
                        fase_navegacion = "CAMBIO_SENTIDO"
                        direccion_giro_cambio = "IZQUIERDA"  # Mantener este giro
                        estado_maniobra = None  # Se iniciarÃ¡ en el prÃ³ximo frame
                        tiempo_inicio_maniobra = None
                        angulo_inicio_cambio = navegador.leer_angulo() if navegador else None
                        intentos_cambio_sentido = 0
                        print(f"\n{'ðŸ”„'*30}")
                        print(f"ðŸ”„ LÃNEA 12 COMPLETADA - INICIANDO CAMBIO DE SENTIDO")
                        print(f"   DirecciÃ³n: IZQUIERDA â†’ Ciclos de 1seg adelante + 1seg atrÃ¡s")
                        print(f"{'ðŸ”„'*30}\n")
                    elif fase_navegacion == "SEGUNDA_ETAPA" and contador_lineas >= LINEAS_POR_SENTIDO:
                        # CompletÃ³ la segunda etapa - FINALIZAR
                        fase_navegacion = "COMPLETADO"
                        estado_giro = None
                        linea_inicial = None
                        print(f"\n{'ðŸ'*30}")
                        print(f"ðŸ Â¡{LINEAS_TOTALES} LÃNEAS COMPLETADAS!")
                        print(f"ðŸ RECORRIDO TERMINADO")
                        print(f"{'ðŸ'*30}\n")
                    else:
                        estado_giro = None
                        linea_inicial = None
                        print("âœ… Giro IZQUIERDA completado (naranja desapareciÃ³)")

                    # Resetear Ã¡ngulo inicial para prÃ³xima detecciÃ³n
                    if navegador:
                        navegador.angulo_inicial = navegador.leer_angulo()
                        navegador.angulo_desde_deteccion = 0

            elif estado_giro == "GIRANDO_DERECHA":
                # Terminar giro solo cuando la segunda lÃ­nea (azul) DESAPAREZCA
                if not hay_azul:
                    # VERIFICAR SI ES LA LÃNEA 12 PARA CAMBIO DE SENTIDO
                    if fase_navegacion == "PRIMERA_ETAPA" and contador_lineas >= LINEAS_POR_SENTIDO:
                        # Iniciar fase de cambio de sentido
                        fase_navegacion = "CAMBIO_SENTIDO"
                        direccion_giro_cambio = "DERECHA"  # Mantener este giro
                        estado_maniobra = None  # Se iniciarÃ¡ en el prÃ³ximo frame
                        tiempo_inicio_maniobra = None
                        angulo_inicio_cambio = navegador.leer_angulo() if navegador else None
                        intentos_cambio_sentido = 0
                        print(f"\n{'ðŸ”„'*30}")
                        print(f"ðŸ”„ LÃNEA 12 COMPLETADA - INICIANDO CAMBIO DE SENTIDO")
                        print(f"   DirecciÃ³n: DERECHA â†’ Ciclos de 1seg adelante + 1seg atrÃ¡s")
                        print(f"{'ðŸ”„'*30}\n")
                    elif fase_navegacion == "SEGUNDA_ETAPA" and contador_lineas >= LINEAS_POR_SENTIDO:
                        # CompletÃ³ la segunda etapa - FINALIZAR
                        fase_navegacion = "COMPLETADO"
                        estado_giro = None
                        linea_inicial = None
                        print(f"\n{'ðŸ'*30}")
                        print(f"ðŸ Â¡{LINEAS_TOTALES} LÃNEAS COMPLETADAS!")
                        print(f"ðŸ RECORRIDO TERMINADO")
                        print(f"{'ðŸ'*30}\n")
                    else:
                        estado_giro = None
                        linea_inicial = None
                        print("âœ… Giro DERECHA completado (azul desapareciÃ³)")

                    # Resetear Ã¡ngulo inicial para prÃ³xima detecciÃ³n
                    if navegador:
                        navegador.angulo_inicial = navegador.leer_angulo()
                        navegador.angulo_desde_deteccion = 0

            # Aplicar direcciÃ³n del giro (SOLO si NO estÃ¡ en CAMBIO_SENTIDO)
            if fase_navegacion != "CAMBIO_SENTIDO":
                if estado_giro in ["IZQUIERDA", "GIRANDO_IZQUIERDA"]:
                    steer = -STEER_LIMIT
                    linea_detectada = 1
                elif estado_giro in ["DERECHA", "GIRANDO_DERECHA"]:
                    steer = STEER_LIMIT_RIGHT  # Usar el lÃ­mite reducido para la derecha
                    linea_detectada = 1
                else:
                    # Usar control de paredes si hay invasiÃ³n significativa en cualquier lado
                    if inv_cam2_total > 0.03 or inv_cam3_total > 0.03:
                        steer = wall_steer
                    else:
                        steer = 0

            # Aplicar lÃ­mites asimÃ©tricos: mÃ¡s rango a la izquierda, menos a la derecha
            steer = int(np.clip(steer, -STEER_LIMIT, STEER_LIMIT_RIGHT))

            # DEBUG: Mostrar steer durante CAMBIO_SENTIDO antes de aplicar al servo
            if fase_navegacion == "CAMBIO_SENTIDO" and frame_count % 10 == 0:
                print(f"   ðŸ”§ steer antes del servo: {steer}")

            # --- CONTROL GPIO: servo y motor ---
            # mapear steer -> -100..100
            steer_norm = int(np.clip(steer / STEER_LIMIT * 100, -100, 100))
            # servo.value espera -1..1
            if servo is not None:
                try:
                    servo_pos = np.clip(steer_norm / 100.0, -1.0, 1.0)
                    servo.value = float(servo_pos)
                    # DEBUG: Mostrar valores del servo durante CAMBIO_SENTIDO
                    if fase_navegacion == "CAMBIO_SENTIDO" and frame_count % 10 == 0:
                        print(f"ðŸŽ® CAMBIO_SENTIDO Servo: steer={steer}, steer_norm={steer_norm}, servo_pos={servo_pos:.3f}")
                    elif frame_count % 30 == 0:
                        print(f"ðŸŽ® Servo: steer={steer}, steer_norm={steer_norm}, servo_pos={servo_pos:.3f}")
                except Exception as e:
                    print("Error controlando servo:", e)

            # motor: velocidad mapeada a 0..1 con control de RPM
            # (SOLO si NO estÃ¡ en CAMBIO_SENTIDO - la maniobra controla el motor directamente)
            if motor is not None and fase_navegacion != "CAMBIO_SENTIDO":
                try:
                    speed = float(np.clip(velocidad / MAX_PWM, 0.0, 1.0))
                    if speed > 0.01:
                        motor.forward(speed)
                        # Mostrar RPM actual cada 10 frames
                        if time.time() % 1.0 < 0.1:  # Aproximadamente cada segundo
                            print(f"  ðŸŽï¸  RPM actual: {motor.current_rpm:.1f} | Target: {TARGET_RPM} | Error: {TARGET_RPM - motor.current_rpm:.1f}")
                    else:
                        motor.stop()
                except Exception as e:
                    print("Error controlando motor:", e)

            # --- VisualizaciÃ³n ---
            # MÃ¡scaras de colores (cÃ¡mara de lÃ­neas - solo ROI)
            cv2.imshow("mask_blue", cv2.resize(roi_mask_blue, (320,180)))
            cv2.imshow("mask_orange", cv2.resize(roi_mask_orange, (320,180)))
            cv2.imshow("mask_edges", cv2.resize(mask_edges, (320,180)))

            # MÃ¡scaras de paredes horizontales (cÃ¡mara de paredes)
            mask_wall_h_combined = cv2.bitwise_or(mask_wall_cam2, mask_wall_cam3)
            cv2.imshow("mask_wall_horizontal", cv2.resize(mask_wall_h_combined, (320,180)))

            # MÃ¡scaras de ROIs bajos
            mask_wall_bajo_combined = cv2.bitwise_or(mask_wall_cam2_bajo, mask_wall_cam3_bajo)
            cv2.imshow("mask_wall_bajo", cv2.resize(mask_wall_bajo_combined, (320,180)))

            # ROIs
            cv2.imshow("roi_c", cv2.resize(roi_c, (320,180)))
            cv2.imshow("roi_cam2", cv2.resize(roi_cam2, (200,100)))
            cv2.imshow("roi_cam3", cv2.resize(roi_cam3, (200,100)))
            cv2.imshow("roi_cam2_bajo", cv2.resize(roi_cam2_bajo, (200,100)))
            cv2.imshow("roi_cam3_bajo", cv2.resize(roi_cam3_bajo, (200,100)))

            # Actualizar el color del contorno segÃºn detecciÃ³n
            # LÃ³gica: mantener el color hasta que aparezca el otro
            if hay_azul and hay_naranja:
                # Ambos detectados - contorno amarillo (mezcla)
                roi_color = (0, 255, 255)  # Amarillo (cyan)
                ultimo_color_detectado = "AMBOS"
            elif hay_azul:
                # Solo azul - contorno azul
                roi_color = (255, 0, 0)  # Azul
                ultimo_color_detectado = "AZUL"
            elif hay_naranja:
                # Solo naranja - contorno naranja
                roi_color = (0, 165, 255)  # Naranja
                ultimo_color_detectado = "NARANJA"
            else:
                # Sin detecciÃ³n - mantener el Ãºltimo color o usar cyan por defecto
                if ultimo_color_detectado == "AZUL":
                    roi_color = (255, 0, 0)  # Mantener azul
                elif ultimo_color_detectado == "NARANJA":
                    roi_color = (0, 165, 255)  # Mantener naranja
                elif ultimo_color_detectado == "AMBOS":
                    roi_color = (0, 255, 255)  # Mantener amarillo
                else:
                    roi_color = (128, 128, 128)  # Gris si nunca ha detectado nada

            # Frame 1 (lÃ­neas - abajo centro) - con ROI marcado con el color detectado
            cv2.rectangle(disp, (x_c, y_c), (x_c+w_c, y_c+h_c), roi_color, 4)

            # Dibujar lÃ­neas detectadas en el ROI
            if blue_low is not None:
                # LÃ­nea azul detectada - dibujar en el frame
                y_blue_global = y_c + blue_low
                cv2.line(disp, (x_c, y_blue_global), (x_c+w_c, y_blue_global), (255, 0, 0), 3)
                cv2.putText(disp, "AZUL", (x_c + 10, y_blue_global - 10),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 0, 0), 2)

            if orange_low is not None:
                # LÃ­nea naranja detectada - dibujar en el frame
                y_orange_global = y_c + orange_low
                cv2.line(disp, (x_c, y_orange_global), (x_c+w_c, y_orange_global), (0, 165, 255), 3)
                cv2.putText(disp, "NARANJA", (x_c + w_c - 120, y_orange_global - 10),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 165, 255), 2)

            # Mostrar estado de detecciÃ³n
            detection_text = []
            if hay_azul:
                detection_text.append("AZUL")
            if hay_naranja:
                detection_text.append("NARANJA")

            if detection_text:
                cv2.putText(disp, f"Detectado: {' + '.join(detection_text)}",
                           (10, FRAME_H - 20), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
            else:
                cv2.putText(disp, f"Ultimo: {ultimo_color_detectado if ultimo_color_detectado else 'NINGUNO'}",
                           (10, FRAME_H - 20), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (128, 128, 128), 2)

            # ===== MOSTRAR INFO DEL MAGNETÃ“METRO EN EL CENTRO (SIEMPRE) =====
            # Crear fondo semi-transparente en el centro
            center_x = FRAME_W // 2
            center_y = FRAME_H // 2
            box_width = 450
            box_height = 200

            overlay = disp.copy()
            cv2.rectangle(overlay,
                         (center_x - box_width//2, center_y - box_height//2),
                         (center_x + box_width//2, center_y + box_height//2),
                         (0, 0, 0), -1)
            cv2.addWeighted(overlay, 0.7, disp, 0.3, 0, disp)

            # Borde del cuadro
            border_color = (0, 255, 255) if MAGNETOMETRO_DISPONIBLE else (0, 0, 255)
            cv2.rectangle(disp,
                         (center_x - box_width//2, center_y - box_height//2),
                         (center_x + box_width//2, center_y + box_height//2),
                         border_color, 3)

            # TÃ­tulo
            titulo = "MAGNETOMETRO" if MAGNETOMETRO_DISPONIBLE else "MAGNETOMETRO (NO DISPONIBLE)"
            cv2.putText(disp, titulo,
                       (center_x - 180, center_y - 75),
                       cv2.FONT_HERSHEY_SIMPLEX, 0.7, border_color, 2)

            if MAGNETOMETRO_DISPONIBLE and navegador:
                # MagnetÃ³metro disponible - mostrar valores
                try:
                    # Usar valores filtrados que no muestran ceros
                    mag_data = navegador.get_magnetometro_valores()
                    mag_x, mag_y, mag_z = mag_data[0], mag_data[1], mag_data[2]
                    angulo_actual = navegador.angulo_actual

                    # Debug: imprimir valores cada segundo
                    if frame_count % 30 == 0:
                        print(f"ðŸ§­ MAG: X={mag_x:+7.1f} Y={mag_y:+7.1f} Z={mag_z:+7.1f} | Ãngulo={angulo_actual:.1f}Â°")

                    # Valores crudos del magnetÃ³metro
                    cv2.putText(disp, f"X: {mag_x:+7.1f}  Y: {mag_y:+7.1f}  Z: {mag_z:+7.1f}",
                               (center_x - 200, center_y - 35),
                               cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)

                    # Ãngulo actual (grande y destacado)
                    cv2.putText(disp, f"Angulo: {angulo_actual:.1f}",
                               (center_x - 100, center_y + 10),
                               cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0, 255, 0), 3)

                    # InformaciÃ³n de navegaciÃ³n si estÃ¡ activa
                    if navegador.activo:
                        cv2.putText(disp, f"Desde deteccion: {navegador.angulo_desde_deteccion:.1f}",
                                   (center_x - 150, center_y + 50),
                                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 165, 0), 2)
                        cv2.putText(disp, f"LINEAS: {contador_lineas}/{LINEAS_POR_SENTIDO} | {fase_navegacion}",
                                   (center_x - 150, center_y + 80),
                                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 255), 2)
                    else:
                        cv2.putText(disp, "Esperando deteccion de linea...",
                                   (center_x - 150, center_y + 50),
                                   cv2.FONT_HERSHEY_SIMPLEX, 0.6, (128, 128, 128), 2)

                except Exception as e:
                    cv2.putText(disp, f"Error leyendo: {str(e)[:40]}",
                               (center_x - 180, center_y),
                               cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 255), 2)
                    if frame_count % 30 == 0:
                        print(f"âŒ Error magnetÃ³metro: {e}")
            else:
                # MagnetÃ³metro NO disponible - mostrar mensaje
                cv2.putText(disp, "Magnetometro no detectado",
                           (center_x - 150, center_y - 20),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)
                cv2.putText(disp, "Verifica conexion I2C",
                           (center_x - 130, center_y + 15),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 128, 0), 2)
                cv2.putText(disp, "Instalar: pip3 install py-qmc5883l",
                           (center_x - 180, center_y + 50),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.5, (128, 128, 128), 1)

            # ===== MOSTRAR INFO DEL NAVEGADOR (ARRIBA) =====
            if navegador and navegador.activo:
                nav_info = navegador.get_info()
                # Fondo semi-transparente para mejor legibilidad
                overlay = disp.copy()
                cv2.rectangle(overlay, (5, 85), (FRAME_W - 5, 140), (0, 0, 0), -1)
                cv2.addWeighted(overlay, 0.6, disp, 0.4, 0, disp)

                # InformaciÃ³n del navegador
                cv2.putText(disp, nav_info, (10, 110),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 255), 2)

                # Indicador visual de estado
                if navegador.completado:
                    status_color = (0, 255, 0)  # Verde = COMPLETADO
                    status_text = "COMPLETADO"
                else:
                    status_color = (0, 165, 255)  # Naranja = EN PROGRESO
                    status_text = "EN PROGRESO"

                cv2.putText(disp, f"Estado: {status_text}", (10, 135),
                           cv2.FONT_HERSHEY_SIMPLEX, 0.5, status_color, 2)

            # Mostrar si estÃ¡ seleccionada
            cam_label = "CAM1: Lineas [SELECCIONADA]" if camera_selected == 1 else "CAM1: Lineas"
            color = (0, 255, 255) if camera_selected == 1 else (0, 255, 0)
            cv2.putText(disp, cam_label, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, color, 2)
            if brightness_cam1 != 0:
                cv2.putText(disp, f"Brillo: {brightness_cam1:+d}", (10, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 2)

            # Frame 2 (pared der - arriba izq) - con ROI horizontal marcado en magenta
            cv2.rectangle(disp2, (CAM2_ROI[0], CAM2_ROI[1]),
                         (CAM2_ROI[0]+CAM2_ROI[2], CAM2_ROI[1]+CAM2_ROI[3]), (255,0,255), 3)
            # ROI bajo en cyan
            cv2.rectangle(disp2, (CAM2_ROI_BAJO[0], CAM2_ROI_BAJO[1]),
                         (CAM2_ROI_BAJO[0]+CAM2_ROI_BAJO[2], CAM2_ROI_BAJO[1]+CAM2_ROI_BAJO[3]), (255,255,0), 3)
            # Mostrar si estÃ¡ seleccionada
            cam_label = "CAM2: Pared Der [SELECCIONADA]" if camera_selected == 2 else "CAM2: Pared Der"
            color = (0, 255, 255) if camera_selected == 2 else (0, 255, 255)
            cv2.putText(disp2, cam_label, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, color, 2)
            if brightness_cam2 != 0:
                cv2.putText(disp2, f"Brillo: {brightness_cam2:+d}", (10, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 2)
            # Mostrar porcentaje de invasiÃ³n en el centro
            cv2.putText(disp2, f"Inv: {inv_cam2*100:.1f}% / {inv_cam2_bajo*100:.1f}%",
                       (FRAME_W//2 - 120, FRAME_H//2), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 0, 255), 2)
            cv2.putText(disp2, f"Total: {inv_cam2_total*100:.1f}%",
                       (FRAME_W//2 - 80, FRAME_H//2 + 35), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)

            # Frame 3 (pared izq - arriba der) - con ROI horizontal marcado en magenta
            cv2.rectangle(disp3, (CAM3_ROI[0], CAM3_ROI[1]),
                         (CAM3_ROI[0]+CAM3_ROI[2], CAM3_ROI[1]+CAM3_ROI[3]), (255,0,255), 3)
            # ROI bajo en cyan
            cv2.rectangle(disp3, (CAM3_ROI_BAJO[0], CAM3_ROI_BAJO[1]),
                         (CAM3_ROI_BAJO[0]+CAM3_ROI_BAJO[2], CAM3_ROI_BAJO[1]+CAM3_ROI_BAJO[3]), (255,255,0), 3)
            # Mostrar si estÃ¡ seleccionada
            cam_label = "CAM3: Pared Izq [SELECCIONADA]" if camera_selected == 3 else "CAM3: Pared Izq"
            color = (0, 255, 255) if camera_selected == 3 else (255, 165, 0)
            cv2.putText(disp3, cam_label, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, color, 2)
            # Mostrar porcentaje de invasiÃ³n en el centro
            cv2.putText(disp3, f"Inv: {inv_cam3*100:.1f}% / {inv_cam3_bajo*100:.1f}%",
                       (FRAME_W//2 - 120, FRAME_H//2), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (255, 165, 0), 2)
            cv2.putText(disp3, f"Total: {inv_cam3_total*100:.1f}%",
                       (FRAME_W//2 - 80, FRAME_H//2 + 35), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)

            # Combinar las 3 cÃ¡maras: arriba 2 lado a lado, abajo 1 centrada
            top_row = np.hstack([
                cv2.resize(disp2, (320, 180)),   # CAM2 arriba izquierda
                cv2.resize(disp3, (320, 180))    # CAM3 arriba derecha
            ])
            bottom_row = cv2.resize(disp, (640, 180))  # CAM1 abajo (mÃ¡s ancha)

            combined_frame = np.vstack([top_row, bottom_row])
            cv2.imshow("frame", combined_frame)

            # Detectar teclas
            key = cv2.waitKey(1) & 0xFF
            if key == 27:  # ESC
                break

            # Ajuste de brillo CAM1 (lÃ­neas)
            elif key == ord('q') or key == ord('Q'):  # Bajar brillo CAM1
                brightness_cam1 = max(-100, brightness_cam1 - 5)
                print(f"ðŸ“· CAM1 Brillo: {brightness_cam1:+d}")
            elif key == ord('w') or key == ord('W'):  # Subir brillo CAM1
                brightness_cam1 = min(100, brightness_cam1 + 5)
                print(f"ðŸ“· CAM1 Brillo: {brightness_cam1:+d}")

            # Ajuste de brillo CAM2 (paredes)
            elif key == ord('e') or key == ord('E'):  # Bajar brillo CAM2
                brightness_cam2 = max(-100, brightness_cam2 - 5)
                print(f"ðŸ“¹ CAM2 Brillo: {brightness_cam2:+d}")
            elif key == ord('r') or key == ord('R'):  # Subir brillo CAM2
                brightness_cam2 = min(100, brightness_cam2 + 5)
                print(f"ðŸ“¹ CAM2 Brillo: {brightness_cam2:+d}")

            # Sistema de intercambio de cÃ¡maras
            elif key == ord('1'):
                if camera_selected is None:
                    camera_selected = 1
                    print("ðŸŽ¥ CAM1 seleccionada. Presiona '2' o '3' para intercambiar.")
                elif camera_selected == 1:
                    camera_selected = None
                    print("âŒ SelecciÃ³n cancelada")
                else:
                    # Intercambiar camera_selected con 1
                    camera_mapping[camera_selected], camera_mapping[1] = camera_mapping[1], camera_mapping[camera_selected]
                    print(f"ðŸ”„ CAM{camera_selected} intercambiada con CAM1")
                    camera_selected = None

            elif key == ord('2'):
                if camera_selected is None:
                    camera_selected = 2
                    print("ðŸŽ¥ CAM2 seleccionada. Presiona '1' o '3' para intercambiar.")
                elif camera_selected == 2:
                    camera_selected = None
                    print("âŒ SelecciÃ³n cancelada")
                else:
                    # Intercambiar camera_selected con 2
                    camera_mapping[camera_selected], camera_mapping[2] = camera_mapping[2], camera_mapping[camera_selected]
                    print(f"ðŸ”„ CAM{camera_selected} intercambiada con CAM2")
                    camera_selected = None

            elif key == ord('3'):
                if camera_selected is None:
                    camera_selected = 3
                    print("ðŸŽ¥ CAM3 seleccionada. Presiona '1' o '2' para intercambiar.")
                elif camera_selected == 3:
                    camera_selected = None
                    print("âŒ SelecciÃ³n cancelada")
                else:
                    # Intercambiar camera_selected con 3
                    camera_mapping[camera_selected], camera_mapping[3] = camera_mapping[3], camera_mapping[camera_selected]
                    print(f"ðŸ”„ CAM{camera_selected} intercambiada con CAM3")
                    camera_selected = None
    finally:
        try:
            input_thread.stop()
        except Exception:
            pass

        # Guardar valores actuales de los trackbars light/mid/dark
        try:
            current_b_light = cv2.getTrackbarPos("B_light", "Adjust Range")
            current_b_mid = cv2.getTrackbarPos("B_mid", "Adjust Range")
            current_b_dark = cv2.getTrackbarPos("B_dark", "Adjust Range")
            current_o_light = cv2.getTrackbarPos("O_light", "Adjust Range")
            current_o_mid = cv2.getTrackbarPos("O_mid", "Adjust Range")
            current_o_dark = cv2.getTrackbarPos("O_dark", "Adjust Range")
        except Exception:
            current_b_light = None
            current_b_mid = None
            current_b_dark = None
            current_o_light = None
            current_o_mid = None
            current_o_dark = None

        try:
            print("\n=== Guardando configuraciÃ³n ===")
            print(f"Blue: light={current_b_light}, mid={current_b_mid}, dark={current_b_dark}")
            print(f"Orange: light={current_o_light}, mid={current_o_mid}, dark={current_o_dark}")
            print(f"CÃ¡maras intercambiadas: {'SÃ' if cameras_swapped else 'NO'}")
        except Exception as e:
            print(f"Error preparando configuraciÃ³n: {e}")

        # Guardar configuraciÃ³n con los 6 valores light/mid/dark
        try:
            config_data = {
                "blue_lo": BLUE_LO.tolist(),
                "blue_hi": BLUE_HI.tolist(),
                "orange_lo": ORANGE_LO.tolist(),
                "orange_hi": ORANGE_HI.tolist(),
                "cameras_swapped": cameras_swapped,
                "b_light": current_b_light,
                "b_mid": current_b_mid,
                "b_dark": current_b_dark,
                "o_light": current_o_light,
                "o_mid": current_o_mid,
                "o_dark": current_o_dark,
                "camera_mapping": camera_mapping
            }
            with open(CONFIG_PATH, 'w') as f:
                json.dump(config_data, f, indent=2)
            print("âœ“ ConfiguraciÃ³n guardada exitosamente (light/mid/dark por color)")
        except Exception as e:
            print(f"Error al guardar configuraciÃ³n: {e}")

        # Detener cÃ¡maras
        cap.stop()
        cap2.stop()
        cap3.stop()
        print("âœ“ 3 CÃ¡maras detenidas")

        cv2.destroyAllWindows()
        # Detener y cerrar motor/servo
        try:
            if motor is not None:
                motor.stop()
                motor.close()
        except Exception:
            pass
        try:
            if servo is not None:
                servo.close()
        except Exception:
            pass

if __name__ == "__main__":
    main()